module.exports = {
  "defaultsOn": "let defaultsOn = function(n, t) {\n  /* [wrapped with _.ary, _.curry, & _.rearg] */\n  n = Qu(n)\n  var r = -1,\n    e = t.length,\n    u = 2 < e ? t[2] : T\n  for (u && Oe(t[0], t[1], u) && (e = 1); ++r < e; )\n    for (var u = t[r], i = Bu(u), o = -1, f = i.length; ++o < f; ) {\n      var c = i[o],\n        a = n[c]\n      ;(a === T || (lu(a, ei[c]) && !oi.call(n, c))) && (n[c] = u[c])\n    }\n  return n\n}\n",
  "eachIndexed": "let eachIndexed = function nu(n, t) {\n  /* [wrapped with _.ary, _.curry, & _.rearg] */\n  return (ff(n) ? r : uo)(n, ye(t, 3))\n}\n",
  "extendOn": "let extendOn = function(t, r) {\n  /* [wrapped with _.ary & _.curry] */\n  var e = -1,\n    u = r.length,\n    i = 1 < u ? r[u - 1] : T,\n    o = 2 < u ? r[2] : T,\n    i = 3 < n.length && typeof i == 'function' ? (u--, i) : T\n  for (\n    o && Oe(r[0], r[1], o) && ((i = 3 > u ? T : i), (u = 1)), t = Qu(t);\n    ++e < u;\n\n  )\n    (o = r[e]) && n(t, o, e, i)\n  return t\n}\n",
  "findIndexed": "let findIndexed = function(t, r, e) {\n  /* [wrapped with _.ary, _.curry, & _.rearg] */\n  var u = Qu(t)\n  if (!su(t)) {\n    var i = ye(r, 3)\n    ;(t = Wu(t)),\n      (r = function(n) {\n        return i(u[n], n, u)\n      })\n  }\n  return (r = n(t, r, e)), -1 < r ? u[i ? t[r] : r] : T\n}\n",
  "getIn": "let getIn = function Ru(n, t, r) {\n  /* [wrapped with _.ary & _.curry] */\n  return (n = null == n ? T : kt(n, t)), n === T ? r : n\n}\n",
  "hasIn": "let hasIn = function(n, t) {\n  /* [wrapped with _.ary & _.curry] */\n  return null != n && we(n, t, Rt)\n}\n",
  "includesIn": "let includesIn = function(n, t, r, e) {\n  /* [wrapped with _.ary & _.curry] */\n  return (\n    (n = su(n) ? n : Uu(n)),\n    (r = r && !e ? Eu(r) : 0),\n    (e = n.length),\n    0 > r && (r = Ui(e + r, 0)),\n    ju(n) ? r <= e && -1 < n.indexOf(t, r) : !!e && -1 < v(n, t, r)\n  )\n}\n",
  "mapIndexed": "let mapIndexed = function ru(n, t) {\n  /* [wrapped with _.ary, _.curry, & _.rearg] */\n  return (ff(n) ? c : Gt)(n, ye(t, 3))\n}\n",
  "mapValuesIndexed": "let mapValuesIndexed = function(n, t) {\n  /* [wrapped with _.ary, _.curry, & _.rearg] */\n  var r = {}\n  return (\n    (t = ye(t, 3)),\n    mt(n, function(n, e, u) {\n      st(r, e, t(n, e, u))\n    }),\n    r\n  )\n}\n",
  "mergeOn": "let mergeOn = function(t, r) {\n  /* [wrapped with _.ary & _.curry] */\n  var e = -1,\n    u = r.length,\n    i = 1 < u ? r[u - 1] : T,\n    o = 2 < u ? r[2] : T,\n    i = 3 < n.length && typeof i == 'function' ? (u--, i) : T\n  for (\n    o && Oe(r[0], r[1], o) && ((i = 3 > u ? T : i), (u = 1)), t = Qu(t);\n    ++e < u;\n\n  )\n    (o = r[e]) && n(t, o, e, i)\n  return t\n}\n",
  "pickByIndexed": "let pickByIndexed = function Lu(n, t) {\n  /* [wrapped with _.ary, _.curry, & _.rearg] */\n  if (null == n) return {}\n  var r = c(ve(n), function(n) {\n    return [n]\n  })\n  return (\n    (t = ye(t)),\n    tr(n, r, function(n, r) {\n      return t(n, r[0])\n    })\n  )\n}\n",
  "pickIn": "let pickIn = function(n, t) {\n  /* [wrapped with _.ary & _.curry] */\n  return null == n ? {} : nr(n, t)\n}\n",
  "pullOn": "let pullOn = function Ke(n, t) {\n  /* [wrapped with _.ary, _.curry, & _.rearg] */\n  return n && n.length && t && t.length ? er(n, t) : n\n}\n",
  "reduceIndexed": "let reduceIndexed = function(n, t, r) {\n  /* [wrapped with _.ary, _.curry, & _.rearg] */\n  var e = ff(n) ? l : j,\n    u = 3 > arguments.length\n  return e(n, ye(t, 4), r, u, uo)\n}\n",
  "setOn": "let setOn = function(n, t, r) {\n  /* [wrapped with _.ary, _.curry, & _.rearg] */\n  return null == n ? n : lr(n, t, r)\n}\n",
  "unsetOn": "let unsetOn = function(n, t) {\n  /* [wrapped with _.ary, _.curry, _.curry, & _.rearg] */\n  return null == n || xr(n, t)\n}\n",
  "updateOn": "let updateOn = function(n, t, r) {\n  /* [wrapped with _.ary, _.curry, & _.rearg] */\n  return null == n ? n : lr(n, t, kr(r)(kt(n, t)), void 0)\n}\n",
  "compactMap": "let compactMap = (fn, collection) =>\n  _2d8‍.a('_', _).flow(_2d8‍.a('_', _).map(fn), _2d8‍.a('_', _).compact)(\n    collection\n  )\n",
  "deepMap": "let deepMap = (fn, obj, _map = map, is = isTraversable) =>\n  _map(e => (is(e) ? deepMap(fn, fn(e), _map, is) : e), obj)\n",
  "findApply": "let findApply = (f, arr) =>\n  _2d8‍.a('_', _).iteratee(f)(_2d8‍.a('_', _).find(f, arr))\n",
  "flowMap": "let flowMap = (...fns) => _2d8‍.a('_', _).map(_2d8‍.a('_', _).flow(...fns))\n",
  "insertAtIndex": "let insertAtIndex = (index, val, collection) =>\n  _2d8‍.a('_', _).isString(collection)\n    ? insertAtStringIndex(index, val, collection)\n    : insertAtArrayIndex(index, val, collection)\n",
  "map": "let map = (f, x) =>\n  (_2d8‍.a('_', _).isArray(x)\n    ? _2d8‍.a('_', _).map\n    : _2d8‍.a('_', _).mapValues\n  ).convert({\n    /* [wrapped with _.curry] */\n    cap: false\n  })(f, x)\n",
  "boundMethod": "let boundMethod = (method, object) => object[method].bind(object)\n",
  "callOrReturn": "let callOrReturn = (fn, ...args) => (_.isFunction(fn) ? fn(...args) : fn)\n",
  "comply": "let comply = (f, g) => x => f(g(x))(x)\n",
  "composeApply": "let composeApply = (f, g) => x => f(g(x))(x)\n",
  "converge": "let converge = (converger, branches) => (...args) =>\n  converger(_.over(branches)(...args))\n",
  "debounceAsync": "let debounceAsync = (n, f) => {\n  let deferred = defer()\n  let debounced = _.debounce(n, (...args) => {\n    deferred.resolve(f(...args))\n    deferred = defer()\n  })\n  return (...args) => {\n    debounced(...args)\n    return deferred.promise\n  }\n}\n",
  "defer": "let defer = () => {\n  let resolve\n  let reject\n  let promise = new Promise((res, rej) => {\n    resolve = res\n    reject = rej\n  })\n  return {\n    resolve,\n    reject,\n    promise\n  }\n}\n",
  "flurry": "let flurry = (...fns) => _.curryN(fns[0].length, f(...fns))\n",
  "mapArgs": "let mapArgs = (mapper, fn) => (...x) => fn(...x.map(mapper))\n",
  "maybeCall": "let maybeCall = (fn, ...args) => _.isFunction(fn) && fn(...args)\n",
  "autoLabel": "let autoLabel = function(t) {\n  return l(Mu(Du(t).replace(kn, '')), n, '')\n}\n",
  "autoLabelOption": "let autoLabelOption = a => ({\n  value: when(_.isUndefined, a)(a.value),\n  label: a.label || autoLabel(when(_.isUndefined, a)(a.value))\n})\n",
  "autoLabelOptions": "let autoLabelOptions = function ru(n, t) {\n  /* [wrapped with _.ary, _.curry, _.partial, & _.rearg] */\n  return (ff(n) ? c : Gt)(n, ye(t, 3))\n}\n",
  "concatStrings": "let concatStrings = function() {\n  var n = arguments,\n    e = n[0]\n  if (o && 1 == n.length && ff(e)) return o.plant(e).value()\n  for (var u = 0, n = r ? t[u].apply(this, n) : e; ++u < r; )\n    n = t[u].call(this, n)\n  return n\n}\n",
  "parens": "let parens = (pre, post, content) => (pre || '') + content + (post || pre || '')\n",
  "quote": "let quote = (pre, post, content) => (pre || '') + content + (post || pre || '')\n",
  "toSentence": "let toSentence = (separator, lastSeparator, array) =>\n  _.flow(\n    intersperse(\n      differentLast(\n        () => separator,\n        () => lastSeparator\n      )\n    ),\n    _.join('')\n  )(array)\n",
  "toSentenceWith": "let toSentenceWith = (separator, lastSeparator, array) =>\n  _.flow(\n    intersperse(\n      differentLast(\n        () => separator,\n        () => lastSeparator\n      )\n    ),\n    _.join('')\n  )(array)\n",
  "trimStrings": "let trimStrings = (f, x) =>\n  (_2d8‍.a('_', _).isArray(x)\n    ? _2d8‍.a('_', _).map\n    : _2d8‍.a('_', _).mapValues\n  ).convert({\n    /* [wrapped with _.curry & _.partial] */\n    cap: false\n  })(f, x)\n",
  "uniqueString": "let uniqueString = (arr = []) => uniqueStringWith(_.countBy(_.identity), arr)\n",
  "uniqueStringWith": "let uniqueStringWith = (cachizer, initialKeys) => {\n  /* [wrapped with _.curry] */\n  let f = x => {\n    let result = x\n    while (cache[result]) {\n      result = x + cache[x]\n      cache[x] += 1\n    }\n    cache[result] = (cache[result] || 0) + 1\n    return result\n  }\n  let cache = cachizer(initialKeys)\n  f.cache = cache\n  f.clear = () => {\n    cache = {}\n    f.cache = cache\n  }\n  return f\n}\n",
  "wrap": "let wrap = (pre, post, content) => (pre || '') + content + (post || pre || '')\n",
  "alias": "let alias = (prop, x) => _.getOr(prop, prop, x)\n",
  "aliasIn": "let aliasIn = (x, prop) => _.getOr(prop, prop, x)\n",
  "cascade": "let cascade = (paths, obj, defaultValue) =>\n  _.flow(\n    findApply(x => x && _.iteratee(x)(obj)),\n    _.defaultTo(defaultValue)\n  )(paths)\n",
  "cascadeIn": "let cascadeIn = (obj, paths, defaultValue) => cascade(paths, obj, defaultValue)\n",
  "cascadeKey": "let cascadeKey = (paths, obj) => _.find(getIn(obj), paths)\n",
  "cascadeProp": "let cascadeProp = (paths, obj) => _.get(cascadePropKey(paths, obj), obj)\n",
  "cascadePropKey": "let cascadePropKey = (paths, obj) => _.find(hasIn(obj), paths)\n",
  "chunkObject": "let chunkObject = value =>\n  _.isArray(value) ? value : _.map(_.spread(singleObject), _.toPairs(value))\n",
  "commonKeys": "let commonKeys = (...x) => fn(...x.map(mapper))\n",
  "compactObject": "let compactObject = function Lu(n, t) {\n  /* [wrapped with _.ary, _.curry, _.partial, & _.rearg] */\n  if (null == n) return {}\n  var r = c(ve(n), function(n) {\n    return [n]\n  })\n  return (\n    (t = ye(t)),\n    tr(n, r, function(n, r) {\n      return t(n, r[0])\n    })\n  )\n}\n",
  "compareDeep": "let compareDeep = (path, item, value) => _.get(path, item) === value\n",
  "diff": "let diff = (original, deltas) => {\n  let o = flattenObject(original)\n  let d = flattenObject(deltas)\n  return _.flow(\n    mapValuesIndexed((_, field) => ({ from: o[field], to: d[field] })),\n    _.omitBy(x => _.isEqual(x.from, x.to))\n  )(_.merge(o, d))\n}\n",
  "diffArray": "let diffArray = function() {\n  var n = arguments,\n    e = n[0]\n  if (o && 1 == n.length && ff(e)) return o.plant(e).value()\n  for (var u = 0, n = r ? t[u].apply(this, n) : e; ++u < r; )\n    n = t[u].call(this, n)\n  return n\n}\n",
  "expandObject": "let expandObject = (transform, obj) => ({\n  /* [wrapped with _.curry] */\n  ...obj,\n  ...transform(obj)\n})\n",
  "expandObjectBy": "let expandObjectBy = (key, fn, obj) => expandObject(getWith(fn, key))(obj)\n",
  "firstCommonKey": "let firstCommonKey = (x, y) => findKeyIndexed((val, key) => _.has(key, x), y)\n",
  "flattenObject": "let flattenObject = (input, paths) =>\n  reduceIndexed(\n    (output, value, key) =>\n      _.merge(\n        output,\n        (isFlatObject(value) ? singleObjectR : flattenObject)(\n          value,\n          dotJoinWith(isNotNil)([paths, key])\n        )\n      ),\n    {},\n    input\n  )\n",
  "getOrReturn": "let getOrReturn = (prop, x) => _.getOr(x, prop, x)\n",
  "getWith": "let getWith = (customizer, path, object) => customizer(_.get(path, object))\n",
  "invertByArray": "let invertByArray = function() {\n  var n = arguments,\n    e = n[0]\n  if (o && 1 == n.length && ff(e)) return o.plant(e).value()\n  for (var u = 0, n = r ? t[u].apply(this, n) : e; ++u < r; )\n    n = t[u].call(this, n)\n  return n\n}\n",
  "isEmptyObject": "let isEmptyObject = function(n, t) {\n  /* [wrapped with _.ary, _.curry, & _.partial] */\n  return Mt(n, t)\n}\n",
  "isFlatObject": "let isFlatObject = function() {\n  var t = arguments\n  switch (t.length) {\n    case 0:\n      return !n.call(this)\n    case 1:\n      return !n.call(this, t[0])\n    case 2:\n      return !n.call(this, t[0], t[1])\n    case 3:\n      return !n.call(this, t[0], t[1], t[2])\n  }\n  return !n.apply(this, t)\n}\n",
  "isNotEmptyObject": "let isNotEmptyObject = function() {\n  var t = arguments\n  switch (t.length) {\n    case 0:\n      return !n.call(this)\n    case 1:\n      return !n.call(this, t[0])\n    case 2:\n      return !n.call(this, t[0], t[1])\n    case 3:\n      return !n.call(this, t[0], t[1], t[2])\n  }\n  return !n.apply(this, t)\n}\n",
  "matchesSignature": "let matchesSignature = (signature, value) =>\n  _.isObject(value) && !_.difference(_.keys(value), signature).length\n",
  "matchesSome": "let matchesSome = function() {\n  var n = arguments,\n    e = n[0]\n  if (o && 1 == n.length && ff(e)) return o.plant(e).value()\n  for (var u = 0, n = r ? t[u].apply(this, n) : e; ++u < r; )\n    n = t[u].call(this, n)\n  return n\n}\n",
  "mergeAllArrays": "let mergeAllArrays = function() {\n  /* [wrapped with _.curry, _.partial, & _.rearg] */\n  var length = arguments.length,\n    lastIndex = length - 1,\n    args = Array(length)\n\n  while (length--) {\n    args[length] = arguments[length]\n  }\n  var array = args[start],\n    otherArgs = args.slice(0, start)\n\n  if (array) {\n    push.apply(otherArgs, array)\n  }\n  if (start != lastIndex) {\n    push.apply(otherArgs, args.slice(start + 1))\n  }\n  return func.apply(this, otherArgs)\n}\n",
  "mergeOverAll": "let mergeOverAll = (fns, ...x) => _.flow(_.over(fns), _.mergeAll)(...x)\n",
  "mergeOverAllArrays": "let mergeOverAllArrays = (customizer, fns, ...x) =>\n  _.flow(_.over(fns), _.mergeAllWith(customizer))(...x)\n",
  "mergeOverAllWith": "let mergeOverAllWith = (customizer, fns, ...x) =>\n  _.flow(_.over(fns), _.mergeAllWith(customizer))(...x)\n",
  "omitBlank": "let omitBlank = x => _.omitBy(isBlank, x)\n",
  "omitEmpty": "let omitEmpty = x => _.omitBy(_.isEmpty, x)\n",
  "omitNil": "let omitNil = x => _.omitBy(_.isNil, x)\n",
  "omitNull": "let omitNull = x => _.omitBy(_.isNull, x)\n",
  "pickInto": "let pickInto = (map, source) => _.mapValues(pickIn(source), map)\n",
  "pickOn": "let pickOn = (paths = [], obj = {}) =>\n  _.flow(\n    _.keys,\n    _.map(key => {\n      if (!_.includes(key, paths)) {\n        delete obj[key]\n      }\n    })\n  )(obj)\n",
  "renameProperty": "let renameProperty = (from, to, target) =>\n  _.has(from, target)\n    ? _.flow(x => _.set(to, _.get(from, x), x), _.unset(from))(target)\n    : target\n",
  "simpleDiff": "let simpleDiff = (original, deltas) => {\n  let o = flattenObject(original)\n  return _.flow(\n    flattenObject,\n    mapValuesIndexed((to, field) => ({ from: o[field], to })),\n    _.omitBy(x => _.isEqual(x.from, x.to))\n  )(deltas)\n}\n",
  "simpleDiffArray": "let simpleDiffArray = function() {\n  var n = arguments,\n    e = n[0]\n  if (o && 1 == n.length && ff(e)) return o.plant(e).value()\n  for (var u = 0, n = r ? t[u].apply(this, n) : e; ++u < r; )\n    n = t[u].call(this, n)\n  return n\n}\n",
  "singleObject": "let singleObject = (key, value) => ({\n  /* [wrapped with _.curry] */\n  [key]: value\n})\n",
  "singleObjectR": "let singleObjectR = (key, value) => ({\n  /* [wrapped with _.curry & _.flip] */\n  [key]: value\n})\n",
  "stampKey": "let stampKey = (key, x) =>\n  mapValuesIndexed(\n    (val, k) => ({\n      /* [wrapped with _.curry] */\n      ...val,\n      [key]: k\n    }),\n    x\n  )\n",
  "stripEmptyObjects": "let stripEmptyObjects = function Lu(n, t) {\n  /* [wrapped with _.ary, _.curry, _.partial, & _.rearg] */\n  if (null == n) return {}\n  var r = c(ve(n), function(n) {\n    return [n]\n  })\n  return (\n    (t = ye(t)),\n    tr(n, r, function(n, r) {\n      return t(n, r[0])\n    })\n  )\n}\n",
  "unflattenObject": "let unflattenObject = x => _.zipObjectDeep(_.keys(x), _.values(x))\n",
  "unkeyBy": "let unkeyBy = (keyName, obj) =>\n  mapIndexed((val, key) =>\n    _.extend(val, {\n      /* [wrapped with _.curry] */\n      [keyName || key]: key\n    })\n  )(obj)\n",
  "unwind": "let unwind = (prop, x) =>\n  ifElse(\n    _.isArray,\n    _.map(y => _.set(prop, y, x)),\n    _.stubArray,\n    _.get(prop, x)\n  )\n",
  "unwindArray": "let unwindArray = (prop, xs) => _.flatMap(unwind(prop))(xs)\n",
  "aspect": "let aspect = ({\n  name = 'aspect',\n  init = _.noop,\n  after = _.noop,\n  before = _.noop,\n  always = _.noop,\n  onError = throws\n  // ?: interceptParams, interceptResult, wrap\n}) => f => {\n  let { state = {} } = f\n  init(state)\n  // Trick to set function.name of anonymous function\n  let x = {\n    [name](...args) {\n      let result\n      let error\n      return Promise.resolve()\n        .then(() => before(args, state))\n        .then(() => f(...args))\n        .then(r => {\n          result = r\n        })\n        .then(() => after(result, state, args))\n        .catch(e => onError(e, state, args))\n        .catch(e => {\n          error = e\n        })\n        .then(() => always(state, args))\n        .then(() => {\n          if (error) throw error\n        })\n        .then(() => result)\n    }\n  }\n  x[name].state = state\n  return x[name]\n}\n",
  "aspectSync": "let aspectSync = ({\n  name = 'aspect',\n  init = _.noop,\n  after = _.noop,\n  before = _.noop,\n  always = _.noop,\n  onError = throws\n  // ?: interceptParams, interceptResult, wrap\n}) => f => {\n  let { state = {} } = f\n  init(state)\n  // Trick to set function.name of anonymous function\n  let x = {\n    [name](...args) {\n      try {\n        before(args, state)\n        let result = f(...args)\n        after(result, state, args)\n        return result\n      } catch (e) {\n        onError(e, state, args)\n        throw e\n      } finally {\n        always(state, args)\n      }\n    }\n  }\n  x[name].state = state\n  return x[name]\n}\n",
  "arrayToObject": "let arrayToObject = (k, v, a) =>\n  _e3b‍.a('_', _).flow(_e3b‍.a('_', _).keyBy(k), _e3b‍.a('_', _).mapValues(v))(\n    a\n  )\n",
  "chunkBy": "let chunkBy = (f, array) =>\n  _e3b‍.a('_', _).isEmpty(array)\n    ? []\n    : _e3b‍\n        .a('_', _)\n        .reduce(\n          (acc, x) =>\n            f(_e3b‍.a('_', _).last(acc), x)\n              ? [..._.initial(acc), [..._.last(acc), x]]\n              : [...acc, [x]],\n          [[_e3b‍.a('_', _).head(array)]],\n          _e3b‍.a('_', _).tail(array)\n        )\n",
  "compactJoin": "let compactJoin = (join, x) =>\n  _e3b‍\n    .a('_', _)\n    .compact(x)\n    .join(join)\n",
  "cycle": "let cycle = (a, n) => a[(a.indexOf(n) + 1) % a.length]\n",
  "dotJoin": "let dotJoin = (join, x) =>\n  _e3b‍\n    .a('_', _)\n    .compact(x)\n    .join(join)\n",
  "dotJoinWith": "let dotJoinWith = fn => x =>\n  _e3b‍\n    .a('_', _)\n    .filter(fn, x)\n    .join('.')\n",
  "encoder": "let encoder = separator => ({\n  encode: compactJoin(separator),\n  decode: _e3b‍.a('_', _).split(separator)\n})\n",
  "intersperse": "let intersperse = (f, [x0, ...xs]) =>\n  _e3b‍.a('reduceIndexed', reduceIndexed)(\n    (acc, x, i) =>\n      i === xs.length\n        ? [...acc, x]\n        : [...acc, _e3b‍.a('callOrReturn', callOrReturn)(f, acc, i, xs), x],\n    [x0],\n    xs\n  )\n",
  "mergeRanges": "let mergeRanges = function() {\n  var n = arguments,\n    e = n[0]\n  if (o && 1 == n.length && ff(e)) return o.plant(e).value()\n  for (var u = 0, n = r ? t[u].apply(this, n) : e; ++u < r; )\n    n = t[u].call(this, n)\n  return n\n}\n",
  "moveIndex": "let moveIndex = (from, to, arr) =>\n  _e3b‍\n    .a('_', _)\n    .flow(\n      _e3b‍.a('_', _).pullAt(from),\n      _e3b‍.a('insertAtIndex', insertAtIndex)(to, arr[from])\n    )(arr)\n",
  "prefixes": "let prefixes = list =>\n  _e3b‍\n    .a('_', _)\n    .range(1, list.length + 1)\n    .map(x => _e3b‍.a('_', _).take(x, list))\n",
  "push": "let push = (val, arr) => arr.concat([val])\n",
  "pushIn": "let pushIn = (arr, val) => arr.concat([val])\n",
  "pushOn": "let pushOn = (arr, val) => {\n  /* [wrapped with _.curry] */\n  arr.push(val)\n  return arr\n}\n",
  "repeated": "let repeated = function() {\n  var n = arguments,\n    e = n[0]\n  if (o && 1 == n.length && ff(e)) return o.plant(e).value()\n  for (var u = 0, n = r ? t[u].apply(this, n) : e; ++u < r; )\n    n = t[u].call(this, n)\n  return n\n}\n",
  "replaceElement": "let replaceElement = (a, b, arr) =>\n  replaceElementBy(_e3b‍.a('_', _).isEqual(a), b, arr)\n",
  "replaceElementBy": "let replaceElementBy = (f, b, arr) =>\n  _e3b‍.a('_', _).map(c => (f(c) ? b : c), arr)\n",
  "toggleElement": "let toggleElement = (check, val, arr) =>\n  (_e3b‍.a('callOrReturn', callOrReturn)(check, val, arr)\n    ? _e3b‍.a('_', _).pull\n    : push)(val, arr)\n",
  "toggleElementBy": "let toggleElementBy = (check, val, arr) =>\n  (_e3b‍.a('callOrReturn', callOrReturn)(check, val, arr)\n    ? _e3b‍.a('_', _).pull\n    : push)(val, arr)\n",
  "zipObjectDeepWith": "let zipObjectDeepWith = (x, y) =>\n  _e3b‍\n    .a('_', _)\n    .zipObjectDeep(\n      x,\n      _e3b‍.a('_', _).isFunction(y) && _e3b‍.a('_', _).isArray(x)\n        ? _e3b‍.a('_', _).times(y, x.length)\n        : y\n    )\n",
  "ifElse": "let ifElse = (condition, onTrue, onFalse, x) =>\n  boolIteratee(condition)(x)\n    ? callOrReturn(onTrue, x)\n    : callOrReturn(onFalse, x)\n",
  "overNone": "let overNone = function() {\n  var n = arguments,\n    e = n[0]\n  if (o && 1 == n.length && ff(e)) return o.plant(e).value()\n  for (var u = 0, n = r ? t[u].apply(this, n) : e; ++u < r; )\n    n = t[u].call(this, n)\n  return n\n}\n",
  "unless": "let unless = (condition, f, x) => ifElse(condition, _.identity, f, x)\n",
  "when": "let when = (condition, t, x) => ifElse(condition, t, _.identity, x)\n",
  "whenExists": "let whenExists = (condition, t, x) => ifElse(condition, t, _.identity, x)\n",
  "whenTruthy": "let whenTruthy = (condition, t, x) => ifElse(condition, t, _.identity, x)\n",
  "allMatches": "let allMatches = (regexStr, str) => {\n  /* [wrapped with _.curry] */\n  let matched\n  const regex = new RegExp(regexStr, 'g')\n  const result = []\n\n  while ((matched = regex.exec(str)) !== null) {\n    result.push({\n      text: matched[0],\n      start: matched.index,\n      end: regex.lastIndex\n    })\n  }\n\n  return result\n}\n",
  "anyWordToRegexp": "let anyWordToRegexp = function() {\n  var n = arguments,\n    e = n[0]\n  if (o && 1 == n.length && ff(e)) return o.plant(e).value()\n  for (var u = 0, n = r ? t[u].apply(this, n) : e; ++u < r; )\n    n = t[u].call(this, n)\n  return n\n}\n",
  "highlight": "let highlight = (start, end, pattern, input) =>\n  highlightFromPostings(\n    start,\n    end,\n    _.isRegExp(pattern)\n      ? postings(pattern, input)\n      : _.flatten(postingsForWords(pattern, input)),\n    input\n  )\n",
  "highlightFromPostings": "let highlightFromPostings = (start, end, postings, str) => {\n  /* [wrapped with _.curry] */\n  let offset = 0\n  _.each(posting => {\n    str = insertAtIndex(posting[0] + offset, start, str)\n    offset += start.length\n    str = insertAtIndex(posting[1] + offset, end, str)\n    offset += end.length\n  }, mergeRanges(postings))\n  return str\n}\n",
  "makeAndTest": "let makeAndTest = options => _.flow(makeRegex(options), testRegex)\n",
  "makeRegex": "let makeRegex = options => text => RegExp(text, options)\n",
  "matchAllWords": "let matchAllWords = (buildRegex, x) => {\n  /* [wrapped with _.curry & _.partial] */\n  // Not inlining so that we don't create the regexp every time\n  const regexp = RegExp(buildRegex(x), 'gi')\n  return y => !!(y && y.match(regexp))\n}\n",
  "matchAnyWord": "let matchAnyWord = (buildRegex, x) => {\n  /* [wrapped with _.curry & _.partial] */\n  // Not inlining so that we don't create the regexp every time\n  const regexp = RegExp(buildRegex(x), 'gi')\n  return y => !!(y && y.match(regexp))\n}\n",
  "postings": "let postings = (regex, str) => {\n  /* [wrapped with _.curry] */\n  var match = regex.exec(str)\n  let result = []\n  if (regex.flags.indexOf('g') < 0 && match) {\n    result.push([match.index, match.index + match[0].length])\n  } else {\n    while (match) {\n      result.push([match.index, regex.lastIndex])\n      match = regex.exec(str)\n    }\n  }\n  return result\n}\n",
  "postingsForWords": "let postingsForWords = (string, str) =>\n  _.reduce(\n    (result, word) => push(postings(RegExp(word, 'gi'), str), result),\n    []\n  )(_.words(string))\n",
  "testRegex": "let testRegex = (regex, str) => new RegExp(regex).test(str)\n",
  "wordsToRegexp": "let wordsToRegexp = function() {\n  var n = arguments,\n    e = n[0]\n  if (o && 1 == n.length && ff(e)) return o.plant(e).value()\n  for (var u = 0, n = r ? t[u].apply(this, n) : e; ++u < r; )\n    n = t[u].call(this, n)\n  return n\n}\n",
  "append": "let append = (x, y) => y + x\n",
  "exists": "let exists = function() {\n  var t = arguments\n  switch (t.length) {\n    case 0:\n      return !n.call(this)\n    case 1:\n      return !n.call(this, t[0])\n    case 2:\n      return !n.call(this, t[0], t[1])\n    case 3:\n      return !n.call(this, t[0], t[1], t[2])\n  }\n  return !n.apply(this, t)\n}\n",
  "isBlank": "let isBlank = function(e) {\n  var u = this\n  return t(r, function(t) {\n    return n(t, u, e)\n  })\n}\n",
  "isBlankDeep": "let isBlankDeep = combinator => x =>\n  combinator(\n    isBlank,\n    _4bf‍\n      .a('tree', tree)()\n      .leaves(x)\n  )\n",
  "isMultiple": "let isMultiple = x => (x || []).length > 1\n",
  "isNotBlank": "let isNotBlank = function() {\n  var t = arguments\n  switch (t.length) {\n    case 0:\n      return !n.call(this)\n    case 1:\n      return !n.call(this, t[0])\n    case 2:\n      return !n.call(this, t[0], t[1])\n    case 3:\n      return !n.call(this, t[0], t[1], t[2])\n  }\n  return !n.apply(this, t)\n}\n",
  "isNotNil": "let isNotNil = function() {\n  var t = arguments\n  switch (t.length) {\n    case 0:\n      return !n.call(this)\n    case 1:\n      return !n.call(this, t[0])\n    case 2:\n      return !n.call(this, t[0], t[1])\n    case 3:\n      return !n.call(this, t[0], t[1], t[2])\n  }\n  return !n.apply(this, t)\n}\n",
  "tapError": "let tapError = f => (e, ...args) => {\n  f(e, ...args)\n  throw e\n}\n",
  "throws": "let throws = x => {\n  throw x\n}\n",
  "flip": "let flip = (...lens) => () => set(!view(...lens), ...lens)\n",
  "fnToObj": "let fnToObj = fn => ({\n  get: fn,\n  set: fn\n})\n",
  "functionLens": "let functionLens = val => (...x) => {\n  if (!x.length) return val\n  val = x[0]\n}\n",
  "includeLens": "let includeLens = (value, ...lens) => ({\n  get: () => _.includes(value, view(...lens)),\n  // Uniq is to ensure multiple calls to set(true) don't push multiple times since this is about membership of a set\n  set: x => set(_.uniq(toggleElementBy(!x, value, view(...lens))), ...lens)\n})\n",
  "lensOf": "let lensOf = object =>\n  _.reduce(\n    (res, key) => {\n      res[key] = lensProp(key, object)\n      return res\n    },\n    {},\n    _.keys(object)\n  )\n",
  "lensProp": "let lensProp = (field, source) => ({\n  get: () => _.get(field, source), //source[field],\n  set(value) {\n    setOn(field, value, source)\n    // source[field] = value\n  }\n})\n",
  "objToFn": "let objToFn = lens => (...values) =>\n  values.length ? lens.set(values[0]) : lens.get()\n",
  "objectLens": "let objectLens = val => ({\n  get: () => val,\n  set(x) {\n    val = x\n  }\n})\n",
  "off": "let off = (val, ...lens) => () => set(val, ...lens)\n",
  "on": "let on = (val, ...lens) => () => set(val, ...lens)\n",
  "set": "let set = (val, ...lens) => write(val, construct(...lens))\n",
  "sets": "let sets = (val, ...lens) => () => set(val, ...lens)\n",
  "setsWith": "let setsWith = (f, ...lens) => x => set(_.iteratee(f)(x), ...lens)\n",
  "stateLens": "let stateLens = ([value, set]) => ({ get: () => value, set })\n",
  "view": "let view = (...lens) => read(construct(...lens))\n",
  "views": "let views = (...lens) => () => view(...lens)\n",
  "findIndexedAsync": "let findIndexedAsync = (f, data, remaining = _.toPairs(data)) => {\n  if (!remaining.length) return\n  let [[key, val], ...rest] = remaining\n  return Promise.resolve(f(val, key, data)).then(result =>\n    result ? val : rest.length ? findIndexedAsync(f, data, rest) : undefined\n  )\n}\n",
  "flatLeaves": "let flatLeaves = (next = traverse) => _802‍.a('_', _).reject(next)\n",
  "flattenTree": "let flattenTree = (next = traverse) => (buildPath = treePath()) =>\n  reduceTree(next)(\n    (result, node, ...x) =>\n      _802‍.a('_', _).set([buildPath(node, ...x)], node, result),\n    {}\n  )\n",
  "isTraversable": "let isTraversable = x =>\n  _802‍.a('_', _).isArray(x) || _802‍.a('_', _).isPlainObject(x)\n",
  "keyTreeByWith": "let keyTreeByWith = (next = traverse) =>\n  _802‍.a('_', _).curry((transformer, groupIteratee, x) =>\n    _802‍.a('_', _).flow(\n      treeToArrayBy(next)(_802‍.a('_', _).iteratee(groupIteratee)),\n      _802‍.a('_', _).uniq,\n      _802‍.a('_', _).keyBy(_802‍.a('_', _).identity),\n      _802‍.a('_', _).mapValues(group =>\n        transformTree(next)(node => {\n          let matches = _802‍.a('_', _).iteratee(groupIteratee)(node) === group\n          transformer(node, matches, group)\n        }, x)\n      )\n    )(x)\n  )\n",
  "leaves": "let leaves = (next = traverse) =>\n  _802‍.a('_', _).flow(treeToArray(next), _802‍.a('_', _).reject(next))\n",
  "propTreePath": "let propTreePath = prop =>\n  treePath(\n    _802‍.a('_', _).flow(treeValues, _802‍.a('_', _).map(prop)),\n    _802‍.a('slashEncoder', slashEncoder)\n  )\n",
  "reduceTree": "let reduceTree = (next = traverse) =>\n  _802‍.a('_', _).curry((f, result, tree) => {\n    walk(next)((...x) => {\n      result = f(result, ...x)\n    })(tree)\n    return result\n  })\n",
  "transformTree": "let transformTree = (next = traverse) =>\n  _802‍.a('_', _).curry((f, x) => {\n    let result = _802‍.a('_', _).cloneDeep(x)\n    walk(next)(f)(result)\n    return result\n  })\n",
  "traverse": "let traverse = x => isTraversable(x) && !_802‍.a('_', _).isEmpty(x) && x\n",
  "tree": "let tree = (next = traverse, buildIteratee = _.identity) => ({\n  walk: walk(next),\n  walkAsync: walkAsync(next),\n  transform: transformTree(next),\n  reduce: reduceTree(next),\n  toArrayBy: treeToArrayBy(next),\n  toArray: treeToArray(next),\n  leaves: leaves(next),\n  lookup: treeLookup(next, buildIteratee),\n  keyByWith: keyTreeByWith(next),\n  traverse: next,\n  flatten: flattenTree(next),\n  flatLeaves: flatLeaves(next)\n})\n",
  "treeKeys": "let treeKeys = (x, i, xs, is) => [i, ...is]\n",
  "treeLookup": "let treeLookup = (next = traverse, buildIteratee = _.identity) =>\n  _802‍\n    .a('_', _)\n    .curry((path, tree) =>\n      _802‍\n        .a('_', _)\n        .reduce(\n          (tree, path) => _802‍.a('_', _).find(buildIteratee(path), next(tree)),\n          tree,\n          path\n        )\n    )\n",
  "treePath": "let treePath = (build = treeKeys, encoder = dotEncoder) => (...args) =>\n  (encoder.encode || encoder)(build(...args).reverse())\n",
  "treeToArray": "let treeToArray = (next = traverse) => treeToArrayBy(next)(x => x)\n",
  "treeToArrayBy": "let treeToArrayBy = (next = traverse) =>\n  _802‍\n    .a('_', _)\n    .curry((fn, tree) =>\n      reduceTree(next)((r, x) => _802‍.a('push', push)(fn(x), r), [], tree)\n    )\n",
  "treeValues": "let treeValues = (x, i, xs) => [x, ...xs]\n",
  "walk": "let walk = (next = traverse) => (\n  pre,\n  post = _.noop,\n  parents = [],\n  parentIndexes = []\n) => (tree, index) =>\n  pre(tree, index, parents, parentIndexes) ||\n  _802‍.a('findIndexed', findIndexed)(\n    walk(next)(pre, post, [tree, ...parents], [index, ...parentIndexes]),\n    next(tree, index, parents, parentIndexes) || []\n  ) ||\n  post(tree, index, parents, parentIndexes)\n",
  "walkAsync": "let walkAsync = (next = traverse) => (\n  pre,\n  post = _.noop,\n  parents = [],\n  parentIndexes = []\n) => (tree, index) =>\n  Promise.resolve(pre(tree, index, parents, parentIndexes))\n    .then(\n      preResult =>\n        preResult ||\n        findIndexedAsync(\n          walkAsync(next)(\n            pre,\n            post,\n            [tree, ...parents],\n            [index, ...parentIndexes]\n          ),\n          next(tree, index, parents, parentIndexes) || []\n        )\n    )\n    .then(stepResult => stepResult || post(tree, index, parents, parentIndexes))\n",
  "differentLast": "let differentLast = (normalCase, lastCase) => (acc, i, list) =>\n  i === list.length - 1\n    ? _.iteratee(lastCase)(acc, i, list)\n    : _.iteratee(normalCase)(acc, i, list)\n",
  "greaterThanOne": "let greaterThanOne = function(t, r) {\n  /* [wrapped with _.ary, _.curry, & _.partial] */\n  return (\n    (typeof t == 'string' && typeof r == 'string') ||\n      ((t = Su(t)), (r = Su(r))),\n    n(t, r)\n  )\n}\n"
}