module.exports = {
  "map arrays": "expect(f.map(x => x * x, [1, 2, 3])).to.deep.equal([1, 4, 9])\n",
  "map plain objects": "expect(f.map(x => x * x, { a: 1, b: 2, c: 3 })).to.deep.equal({\n  a: 1,\n  b: 4,\n  c: 9\n})\n",
  "deepMap arrays": "const arr = [0, [1, [2, []]]]\n\nconst arrBackup = _.cloneDeep(arr)\n\nconst arrMutated = f.deepMap(e => e.concat(101), arr)\n\n// Checking immutability\nexpect(arr).to.eql(arrBackup)\n\nexpect(arrMutated).to.eql([0, [1, [2, [101], 101], 101]])\n",
  "deepMap plain objects": "const obj = {\n  a: {\n    match: {\n      id: 1\n    },\n    b: {\n      match: {\n        id: 2\n      },\n      c: {\n        match: {\n          id: 3\n        }\n      }\n    }\n  }\n}\n\nconst objBackup = _.cloneDeep(obj)\n\nconst path = 'match.matched'\nconst setMatched = e => e.match && _.set(path, true, e)\nconst objMutated = f.deepMap(e => setMatched(e) || e)(obj)\n\n// Checking immutability\nexpect(obj).to.eql(objBackup)\n\nexpect(objMutated).to.eql({\n  a: {\n    match: {\n      id: 1,\n      matched: true\n    },\n    b: {\n      match: {\n        id: 2,\n        matched: true\n      },\n      c: {\n        match: {\n          id: 3,\n          matched: true\n        }\n      }\n    }\n  }\n})\n",
  "deepMap plain objects with arrays with objects": "const obj = {\n  a: {\n    array: [0, [1, [2, [{ match: { id: 0 } }]]]],\n    match: {\n      id: 1\n    },\n    b: {\n      match: {\n        id: 2\n      },\n      c: {\n        match: {\n          id: 3\n        }\n      }\n    }\n  }\n}\n\nconst objBackup = _.cloneDeep(obj)\n\nconst path = 'match.matched'\nconst setMatched = e => e.match && _.set(path, true, e)\nconst push101 = e => _.isArray(e) && e.concat(101)\nconst objMutated = f.deepMap(e => push101(e) || setMatched(e) || e)(obj)\n\n// Checking immutability\nexpect(obj).to.eql(objBackup)\n\nexpect(objMutated).to.eql({\n  a: {\n    array: [\n      0,\n      [1, [2, [{ match: { id: 0, matched: true } }, 101], 101], 101],\n      101\n    ],\n    match: {\n      id: 1,\n      matched: true\n    },\n    b: {\n      match: {\n        id: 2,\n        matched: true\n      },\n      c: {\n        match: {\n          id: 3,\n          matched: true\n        }\n      }\n    }\n  }\n})\n",
  "compactJoin": "expect(F.compactJoin(',', [1, undefined, 2, null, 3])).to.eql('1,2,3')\nexpect(F.compactJoin(' and ', [null, 'Alice', 'Bob', false])).to.eql(\n  'Alice and Bob'\n)\n",
  "dotJoin": "expect(F.dotJoin([1, undefined, 2, null, 3])).to.eql('1.2.3')\nexpect(F.dotJoin([null, 'Alice', 'Bob', false])).to.eql('Alice.Bob')\n",
  "repeated": "expect(F.repeated([1, 1, 2, 3, 3, 4])).to.eql([1, 3])\nexpect(F.repeated(['a', 'b', 'b'])).to.eql(['b'])\n",
  "mergeRanges": "expect(\n  F.mergeRanges([\n    [0, 2],\n    [1, 4]\n  ])\n).to.deep.equal([[0, 4]])\nexpect(F.mergeRanges([null, [1, 4]])).to.deep.equal([[1, 4]])\nexpect(\n  F.mergeRanges([\n    [0, 1],\n    [1, 4],\n    [2, 4],\n    [3, 5]\n  ])\n).to.deep.equal([[0, 5]])\n",
  "cycle": "let cycle = F.cycle([1, 2, 3])\nexpect(cycle(1)).to.equal(2)\nexpect(cycle(2)).to.equal(3)\nexpect(cycle(3)).to.equal(1)\nexpect(cycle(4)).to.equal(1)\n\ncycle = F.cycle([true, false])\nexpect(cycle(true)).to.equal(false)\nexpect(cycle(false)).to.equal(true)\nexpect(cycle(null)).to.equal(true)\n\nexpect(F.cycle([true, false], true)).to.equal(false)\n",
  "arrayToObject": "expect(\n  F.arrayToObject(\n    x => `key${x}`,\n    x => `val${x}`,\n    ['a', 'b', 'c']\n  )\n).to.deep.equal({ keya: 'vala', keyb: 'valb', keyc: 'valc' })\n",
  "pushIn": "let fn = F.pushIn([1, 2, 3])\nexpect(fn(4)).to.deep.equal([1, 2, 3, 4])\n",
  "pushOn": "let arr = [1, 2, 3]\nlet fn = F.pushOn(arr)\nexpect(fn(4)).to.deep.equal([1, 2, 3, 4])\nexpect(arr).to.deep.equal([1, 2, 3, 4])\n",
  "moveIndex": "let arr = [1, 2, 3]\nlet x = F.moveIndex(1, 0, arr)\nexpect(x).to.deep.equal([2, 1, 3])\nexpect(arr).to.deep.equal([1, 2, 3])\n",
  "zipObjectDeepWith": "expect(F.zipObjectDeepWith(['a', 'b'], () => 1)).to.deep.equal({\n  a: 1,\n  b: 1\n})\n",
  "flags": "expect(F.flags(['a', 'b', 'c'])).to.deep.equal({\n  a: true,\n  b: true,\n  c: true\n})\n",
  "prefixes": "expect(F.prefixes(['root', 'criteria', 'someNode'])).to.deep.equal([\n  ['root'],\n  ['root', 'criteria'],\n  ['root', 'criteria', 'someNode']\n])\nexpect(F.prefixes('abc')).to.deep.equal([['a'], ['a', 'b'], ['a', 'b', 'c']])\n",
  "encoder": "let encoder = F.encoder('->')\nexpect(encoder.encode(['a', 'b'])).to.deep.equal('a->b')\nexpect(encoder.decode('a->b')).to.deep.equal(['a', 'b'])\n",
  "dotEncoder": "expect(F.dotEncoder.encode(['a', 'b'])).to.deep.equal('a.b')\nexpect(F.dotEncoder.decode('a.b')).to.deep.equal(['a', 'b'])\n",
  "slashEncoder": "expect(F.slashEncoder.encode(['a', 'b'])).to.deep.equal('a/b')\nexpect(F.slashEncoder.decode('a/b')).to.deep.equal(['a', 'b'])\n",
  "chunkBy": "expect(F.chunkBy(([a], b) => b % a === 0, [2, 2, 2, 3, 2, 2])).to.deep.equal([\n  [2, 2, 2],\n  [3],\n  [2, 2]\n])\nexpect(\n  F.chunkBy(([x], y) => (x * y) % 3 === 0)([1, 2, 3, 4, 5, 6, 7, 8, 9])\n).to.deep.equal([[1], [2, 3], [4], [5, 6], [7], [8, 9]])\n// edge cases\nexpect(F.chunkBy(() => true, [])).to.deep.equal([])\nexpect(F.chunkBy(() => true, undefined)).to.deep.equal([])\nexpect(F.chunkBy(() => true, [])).to.deep.equal([])\nexpect(F.chunkBy(() => false, [])).to.deep.equal([])\nexpect(F.chunkBy(() => false, undefined)).to.deep.equal([])\nexpect(F.chunkBy(() => false, [])).to.deep.equal([])\n",
  "toggleElement": "expect(F.toggleElement('b', ['a', 'b', 'c', 'd'])).to.deep.equal([\n  'a',\n  'c',\n  'd'\n])\nexpect(F.toggleElement('b', ['a', 'c', 'd'])).to.deep.equal([\n  'a',\n  'c',\n  'd',\n  'b'\n])\n",
  "toggleElementBy": "let list = ['a', 'b', 'c']\nlet valueToToggle = 'b'\n\nlet toggleB = shouldAdd => F.toggleElementBy(!shouldAdd, valueToToggle, list)\n\nexpect(toggleB(true)).to.deep.equal(['a', 'b', 'c', 'b'])\nexpect(toggleB(false)).to.deep.equal(['a', 'c'])\n",
  "intersperse": "expect(\n  F.intersperse((acc, i, xs) => (i === xs.length - 1 ? 'and finally' : 'and'), [\n    1,\n    2,\n    3\n  ])\n).to.deep.equal([1, 'and', 2, 'and finally', 3])\nexpect(F.intersperse('and', [1, 2, 3])).to.deep.equal([1, 'and', 2, 'and', 3])\n",
  "replaceElementBy": "expect(F.replaceElementBy(c => c > 10, 0, [1, 11, 3, 5])).to.deep.equal([\n  1,\n  0,\n  3,\n  5\n])\n",
  "replaceElement": "expect(F.replaceElement(11, 0, [1, 11, 3, 5])).to.deep.equal([1, 0, 3, 5])\n",
  "combine aspect states": "let f = Command(() => 6)\nexpect(f.state.status).to.equal(null)\nexpect(f.state.processing).to.equal(false)\nexpect(f.state.failed).to.equal(false)\nexpect(f.state.succeeded).to.equal(false)\nexpect(f.state.logs).to.deep.equal([])\nexpect(f.state.errors).to.deep.equal([])\n",
  "support .after calls (`logs` aspect)": "let f = Command(() => 6)\nawait f()\nexpect(f.state.logs).to.deep.equal([6])\nawait f()\nexpect(f.state.logs).to.deep.equal([6, 6])\n",
  "support .onError and before (`concurrency`, `errors`, and `status` aspects)": "let g = Command(() => {\n  throw Error(5)\n})\nexpect(g.state.processing).to.equal(false)\nawait g()\nexpect(g.state.errors[0].message).to.equal('5')\nexpect(g.state.processing).to.equal(false)\n// Should be blocked as a concurrent run since it's still processing\ng.state.processing = true\nawait g()\nexpect(g.state.errors[1].message).to.equal('Concurrent Runs Not Allowed')\n",
  "support throwing in onError": "// Use the single error object to avoid 'Unhandled promise rejection' in\n// some browsers.\nlet theException = new Error('hi from aspect')\nlet ThrowHi = aspect({\n  onError() {\n    throw theException\n  }\n})\nlet throwsHi = ThrowHi(() => {\n  throw Error('Not hi')\n})\n\nexpect(throwsHi()).to.be.rejectedWith(theException)\n",
  "support single error": "let throwsHi = aspects.error()(() => {\n  throw Error('Hi')\n})\nawait throwsHi()\nexpect(throwsHi.state.error.message).to.deep.equal('Hi')\n",
  "support status and clearing status": "// Increase the timeout/delay to hundreds ms to make testing IE9/10/11 more\n// stable & avoid exception:\n// AssertionError: expected null to equal 'processing'\nlet clearingStatus = aspects.command(undefined, 250)\nlet f = clearingStatus(async () => Promise.delay(200))\nlet result = f()\nawait Promise.delay(100)\nexpect(f.state.status).to.equal('processing')\nexpect(f.state.processing).to.equal(true)\nawait result\nexpect(f.state.status).to.equal('succeeded')\nexpect(f.state.succeeded).to.equal(true)\nawait Promise.delay(300)\nexpect(f.state.status).to.equal(null)\nlet g = clearingStatus(async () => {\n  throw Error('error')\n})\nawait g()\nexpect(g.state.status).to.equal('failed')\nexpect(g.state.failed).to.equal(true)\nawait Promise.delay(15)\nexpect(f.state.status).to.equal(null)\n",
  "support synchronous aspects": "let x = 1\nlet y = 0\nlet firstIncrementX = aspectSync({\n  before() {\n    x++\n  }\n})\nlet f = firstIncrementX(() => {\n  y = x\n})\nf()\nexpect(y).to.equal(2)\n",
  "flowMap": "expect(\n  F.flowMap(\n    n => n + n,\n    n => n * n\n  )([0, 1, 2, 3, 4])\n).to.eql([0, 4, 16, 36, 64])\nexpect(\n  F.flowMap(\n    s => s.toUpperCase(),\n    s => s.split(''),\n    s => s.reverse(),\n    s => s.join('')\n  )(['Smart', 'Procure'])\n).to.eql(['TRAMS', 'ERUCORP'])\n",
  "findApply": "let x = {\n  a: 1\n}\nexpect(F.findApply(f => x[f], ['b', 'c', 'a'])).to.equal(1)\nexpect(F.findApply(f => x[f], ['b', 'c'])).to.equal(undefined)\nlet xs = [{ b: 2 }, { c: 3 }, { a: 1 }]\nexpect(F.findApply(f => f.a, xs)).to.equal(1)\nexpect(F.findApply('a', xs)).to.equal(1)\nexpect(F.findApply('d', xs)).to.equal(undefined)\n",
  "insertAtIndex": "let arr = [1, 2, 3]\nlet x = F.insertAtIndex(1, 5, arr)\nexpect(x).to.deep.equal([1, 5, 2, 3])\nexpect(arr).to.deep.equal([1, 2, 3])\n\nexpect(F.insertAtIndex(1, 'z', 'abc')).to.deep.equal('azbc')\n\nvar result = F.insertAtIndex(0, '<span>', 'pretty please')\nexpect(result).to.equal('<span>pretty please')\n",
  "compactMap": "let names = ['adam', 'betty', 'carlos', 'doug', 'emily']\nlet exceptDoug = fn => x => (x === 'doug' ? undefined : fn(x))\nexpect(F.compactMap(_.capitalize, names)).to.deep.equal([\n  'Adam',\n  'Betty',\n  'Carlos',\n  'Doug',\n  'Emily'\n])\nexpect(F.compactMap(exceptDoug(_.capitalize), names)).to.deep.equal([\n  'Adam',\n  'Betty',\n  'Carlos',\n  'Emily'\n])\nexpect(F.compactMap(x => x - 2, [0, 1, 2, 3])).to.deep.equal([-2, -1, 1])\n",
  "getIn": "expect(f.getIn(hero, 'name')).to.eql(hero.name)\nconst obj = { a: 1 }\nexpect(f.inversions.getIn(obj)('a')).to.equal(1)\nexpect(f.getIn(obj)('a')).to.equal(1)\n",
  "pickIn": "expect(f.pickIn(hero, 'name')).to.eql(_.pick('name', hero))\nexpect(f.pickIn(hero, ['name', 'father'])).to.eql(\n  _.pick(['name', 'father'], hero)\n)\n",
  "includesIn": "let expectEql = (obj, name) =>\n  expect(f.includesIn(obj, name)).to.eql(_.includes(name, obj))\nexpectEql(hero, 'name')\nexpectEql(hero, 'Heracles')\nexpectEql(hero, 'Zeus')\n",
  "extendOn": "let expectEql = (clone, obj) =>\n  expect(f.extendOn(clone, obj)).to.eql(_.extend(obj, clone))\nexpectEql(_.clone(hero), { name: 'Hercules' })\nexpectEql(_.clone(hero), { consort: 'Auge' })\nexpect(\n  f.extendOn(\n    {\n      a: 1\n    },\n    {\n      a: 2,\n      b: 3,\n      c: 4\n    }\n  )\n).to.deep.equal({\n  a: 2,\n  b: 3,\n  c: 4\n})\n",
  "defaultsOn": "let clone = _.clone(hero)\nlet defaultsResult = _.defaults({ consort: 'Auge' }, clone)\nexpect(f.defaultsOn(clone, { consort: 'Auge' })).to.eql(defaultsResult)\nexpect(\n  f.defaultsOn(\n    {\n      a: 2,\n      b: 3,\n      c: 4\n    },\n    {\n      a: 1\n    }\n  )\n).to.deep.equal({\n  a: 1,\n  b: 3,\n  c: 4\n})\n",
  "debounceAsync": "let inner = sinon.spy(x => x + 10)\nlet fn = F.debounceAsync(10, inner)\nlet result = await Promise.all([fn(1), fn(2), fn(3)])\nexpect(inner).to.have.callCount(1)\nexpect(result).to.deep.equal([13, 13, 13])\nlet secondResult = await Promise.all([fn(11), fn(12), fn(13)])\nexpect(secondResult).to.deep.equal([23, 23, 23])\n",
  "demonstrate failing with regular debounce": "let inner = sinon.spy(x => x + 10)\nlet fn = _.debounce(10, inner)\nlet result = await Promise.all([fn(1), fn(2), fn(3)])\nexpect(inner).to.have.callCount(0)\nexpect(result).to.deep.equal([undefined, undefined, undefined])\nlet secondResult = await Promise.all([fn(11), fn(12), fn(13)])\nexpect(secondResult).to.deep.equal([undefined, undefined, undefined])\n",
  "flurry": "let add = (x, y) => x + y\nlet double = x => x * 2\n\n// Passing all args\nexpect(F.flurry(add, double)(1, 4)).to.equal(10)\n// Passing 1 at a time\nexpect(F.flurry(add, double)(1)(4)).to.equal(10)\n",
  "mapArgs": "let add = (x, y) => x + y\nlet double = x => x * 2\nlet doubledAdd = F.mapArgs(double, add)\n// (5*2) + (7*2)\nexpect(doubledAdd(5, 7)).to.equal(24)\n",
  "differentLast": "expect(\n  F.mapIndexed(F.differentLast('a', 'b'), [\n    { a: 1, b: 2 },\n    { a: 1, b: 2 },\n    { a: 1, b: 2 }\n  ])\n).to.eql([1, 1, 2])\n",
  "throws": "expect(() => f.throws(Error('oops'))).to.throw()\n",
  "isNotNil": "expect(f.isNotNil(null)).to.equal(false)\nexpect(f.isNotNil(undefined)).to.equal(false)\nexpect(f.isNotNil(0)).to.equal(true)\nexpect(f.isNotNil('')).to.equal(true)\nexpect(f.isNotNil([])).to.equal(true)\n",
  "exists": "expect(f.exists).to.equal(f.isNotNil)\n",
  "isMultiple": "expect(f.isMultiple([''])).to.equal(false)\nexpect(f.isMultiple(['', ''])).to.equal(true)\nexpect(f.isMultiple('a')).to.equal(false)\nexpect(f.isMultiple('asdf')).to.equal(true)\nexpect(f.isMultiple({ x: 1, y: 2 })).to.equal(false)\nexpect(f.isMultiple({ x: 1, y: 2, length: 2 })).to.equal(true)\n",
  "append": "expect(f.append('a', 'b')).to.equal('ba')\nexpect(f.append(1, 4)).to.equal(5)\n",
  "isBlank": "expect(f.isBlank(1)).to.equal(false)\nexpect(f.isBlank('asdf')).to.equal(false)\nexpect(f.isBlank({ a: 1 })).to.equal(false)\nexpect(f.isBlank([3, 4])).to.equal(false)\nexpect(f.isBlank(new Date())).to.equal(false)\nexpect(\n  f.isBlank({\n    a: 1,\n    b: 'as'\n  })\n).to.equal(false)\nexpect(f.isBlank(null)).to.equal(true)\nexpect(f.isBlank(undefined)).to.equal(true)\nexpect(f.isBlank('')).to.equal(true)\nexpect(f.isBlank([])).to.equal(true)\nexpect(f.isBlank({})).to.equal(true)\n",
  "isBlankDeep": "expect(f.isBlankDeep(_.every)(1)).to.equal(false)\nexpect(f.isBlankDeep(_.every)(false)).to.equal(false)\nexpect(f.isBlankDeep(_.every)('')).to.equal(true)\nexpect(\n  f.isBlankDeep(_.every)({\n    a: 1,\n    b: 'as'\n  })\n).to.equal(false)\nexpect(\n  f.isBlankDeep(_.every)({\n    a: null,\n    b: '',\n    c: [],\n    d: {\n      b: ''\n    }\n  })\n).to.equal(true)\n",
  "functionLens": "let l = F.functionLens(1)\nexpect(l()).to.equal(1)\nl(5)\nexpect(l()).to.equal(5)\n",
  "objectLens": "let l = F.objectLens(1)\nexpect(l.get()).to.equal(1)\nl.set(5)\nexpect(l.get()).to.equal(5)\n",
  "fnToObj": "let l = F.fnToObj(F.functionLens(1))\nexpect(l.get()).to.equal(1)\nl.set(5)\nexpect(l.get()).to.equal(5)\n",
  "objToFn": "let l = F.objToFn(F.objectLens(1))\nexpect(l()).to.equal(1)\nl(5)\nexpect(l()).to.equal(5)\n",
  "lensProp": "let l = F.lensProp('x', {\n  x: 1\n})\nexpect(l.get()).to.equal(1)\nl.set(5)\nexpect(l.get()).to.equal(5)\n",
  "lensProp deep": "let l = F.lensProp('x.a', {\n  x: {\n    a: 1\n  }\n})\nexpect(l.get()).to.equal(1)\nl.set(5)\nexpect(l.get()).to.equal(5)\n",
  "lensOf": "let l = F.lensOf({\n  a: 1\n})\nexpect(l.a.get()).to.equal(1)\nl.a.set(5)\nexpect(l.a.get()).to.equal(5)\n",
  "includeLens": "let object = {\n  arr: ['a', 'b', 'c', 'd']\n}\nlet includesB = F.includeLens('b', 'arr', object)\nexpect(F.view(includesB)).to.be.true\nF.off(includesB)()\nexpect(F.view(includesB)).to.be.false\nexpect(object.arr).to.deep.equal(['a', 'c', 'd'])\nF.on(includesB)()\nexpect(F.view(includesB)).to.be.true\nexpect(object.arr).to.deep.equal(['a', 'c', 'd', 'b'])\n// Subsequent calls don't result in multiple `b`s because of _.uniq\nF.on(includesB)()\nexpect(F.view(includesB)).to.be.true\nexpect(object.arr).to.deep.equal(['a', 'c', 'd', 'b'])\n",
  "view": "let x = {\n  a: 1,\n  b: 2\n}\nexpect(F.view('a', x)).to.equal(1)\n",
  "views": "let x = {\n  a: 1,\n  b: 2\n}\nexpect(F.views('a', x)()).to.equal(1)\n",
  "set": "let x = {\n  a: 1,\n  b: 2\n}\nF.set(5, 'a', x)\nexpect(x.a).to.equal(5)\n",
  "sets": "let x = {\n  a: 1,\n  b: 2\n}\nF.sets(5, 'a', x)()\nexpect(x.a).to.equal(5)\n",
  "setsWith": "let object = {\n  a: 1\n}\nlet setter = F.setsWith(x => x * 2, 'a', object)\nsetter(5)\nexpect(object.a).to.equal(10)\n",
  "flip": "let object = {\n  a: 1\n}\nF.flip('a', object)()\nexpect(object.a).to.equal(false)\n",
  "on": "let object = {\n  a: 1\n}\nF.on('a', object)()\nexpect(object.a).to.equal(true)\n",
  "off": "let object = {\n  a: 1\n}\nF.off('a', object)()\nexpect(object.a).to.equal(false)\n",
  "arrayLens": "let arrayLens = val => {\n  let result = [val]\n  result.push(x => {\n    result[0] = x\n  })\n  return result\n}\nlet lens = arrayLens(false)\nF.on(lens)()\nexpect(lens[0]).to.be.true\nF.off(lens)()\nexpect(lens[0]).to.be.false\nF.flip(lens)()\nexpect(lens[0]).to.be.true\n",
  "functionPairLens": "let object = {\n  a: false\n}\nlet get = () => object.a\nlet set = x => {\n  object.a = x\n}\nF.on(get, set)()\nexpect(object.a).to.be.true\nF.off(get, set)()\nexpect(object.a).to.be.false\nF.flip(get, set)()\nexpect(object.a).to.be.true\n",
  "value": "let state = {\n  a: 1\n}\nlet props = F.domLens.value('a', state)\nexpect(props.value).to.equal(1)\nprops.onChange({ target: { value: 5 } })\nexpect(state.a).to.equal(5)\n",
  "non-native value": "let state = {\n  a: 1\n}\nlet props = F.domLens.value('a', state)\nexpect(props.value).to.equal(1)\nprops.onChange(5)\nexpect(state.a).to.equal(5)\n",
  "checkboxValues": "let state = {\n  a: ['x', 'y', 'z']\n}\n// Props for if `x` is in the list\nlet props = F.domLens.checkboxValues('x', 'a', state)\nexpect(props.checked).to.equal(true)\n// uncheck\nprops.onChange({ target: { value: false } })\nexpect(_.includes('a', state.a)).to.be.false\n",
  "hover": "let state = {\n  hovering: false\n}\nlet props = F.domLens.hover('hovering', state)\nprops.onMouseEnter()\nexpect(state.hovering).to.be.true\nprops.onMouseLeave()\nexpect(state.hovering).to.be.false\n",
  "focus": "let state = {\n  focusing: false\n}\nlet props = F.domLens.focus('focusing', state)\nprops.onFocus()\nexpect(state.focusing).to.be.true\nprops.onBlur()\nexpect(state.focusing).to.be.false\n",
  "targetBinding": "let state = {\n  flag: false\n}\nlet props = F.domLens.targetBinding('checked')('flag', state)\nexpect(props.checked).to.be.false\nprops.onChange({ target: { checked: true } })\nexpect(state.flag).to.be.true\n",
  "binding": "let state = {\n  selectedItem: 'item1'\n}\nlet weirdSelect = F.domLens.binding('selected', e => e.newSelectedValue)\nlet props = weirdSelect('selectedItem', state)\nexpect(props.selected).to.equal('item1')\nprops.onChange({ newSelectedValue: 'newItem' })\nexpect(state.selectedItem).to.equal('newItem')\n",
  "handle functions": "let clamp5 = f.ifElse(\n  x => x > 5,\n  () => 5,\n  x => x\n)\nexpect(clamp5(3)).to.equal(3)\nexpect(clamp5(5)).to.equal(5)\nexpect(clamp5(13)).to.equal(5)\n",
  "handle passing boolean conditions": "let fn = f.ifElse(\n  true,\n  x => `success ${x}`,\n  x => `fail ${x}`\n)\nexpect(fn(1)).to.equal('success 1')\n",
  "handle fancy shorthand": "let fancyShortHand = f.ifElse({ a: 1 }, 'Has a1', () => 'No a1')\nexpect(fancyShortHand({ a: 1 })).to.equal('Has a1')\nexpect(fancyShortHand({ a: 2 })).to.equal('No a1')\n",
  "be fully curried": "expect(\n  f.ifElse(\n    x => x % 2,\n    x => `${x} is odd!`,\n    x => `${x} is even!`,\n    6\n  )\n).to.equal('6 is even!')\n",
  "when": "let clamp5 = f.when(\n  x => x > 5,\n  () => 5\n)\nexpect(clamp5(3)).to.equal(3)\nexpect(clamp5(5)).to.equal(5)\nexpect(clamp5(13)).to.equal(5)\n",
  "unless": "let clamp5 = f.unless(\n  x => x < 5,\n  () => 5\n)\nexpect(clamp5(3)).to.equal(3)\nexpect(clamp5(5)).to.equal(5)\nexpect(clamp5(13)).to.equal(5)\n",
  "whenExists": "let fn = f.whenExists(5)\nexpect(fn(3)).to.equal(5)\nexpect(fn(null)).to.equal(null)\nexpect(fn(false)).to.equal(5)\n",
  "whenTruthy": "let fn = f.whenTruthy(5)\nexpect(fn(3)).to.equal(5)\nexpect(fn(null)).to.equal(null)\nexpect(fn(false)).to.equal(false)\n",
  "maybeCall": "expect(F.maybeCall(() => 5)).to.deep.equal(5)\nexpect(F.maybeCall(null)).to.deep.equal(false)\n",
  "maybeCall call fn with parameters": "const fn = (x, y) => x + y\nconst result = fn(5, 6)\nexpect(F.maybeCall(fn, 5, 6)).to.deep.equal(result)\n",
  "boundMethod bind a method of an object to it's object": "let obj = {\n  name: 'Wade Watts',\n  greet() {\n    return `Welcome, ${this.name}`\n  }\n}\nexpect(obj.greet.call({ name: 'John Henry' })).to.equal('Welcome, John Henry')\nexpect(F.boundMethod('greet', obj)()).to.equal('Welcome, Wade Watts')\n",
  "comply": "// (5 * 2) +  5\nexpect(F.comply(F.append, x => x * 2)(5)).to.equal(15)\n",
  "greaterThanOne": "for (let i = -10; i < 10; i++) {\n  expect(F.greaterThanOne(i)).to.equal(i > 1)\n}\n",
  "export the VERSION": "expect(F.VERSION).to.equal(global.__VERSION__)\n",
  "singleObject": "expect(F.singleObject('a', 'b')).to.deep.equal({\n  a: 'b'\n})\n",
  "singleObjectR": "expect(F.singleObjectR('a', 'b')).to.deep.equal({\n  b: 'a'\n})\n",
  "chunkObject": "expect(F.chunkObject([1])).to.deep.equal([1])\nexpect(\n  F.chunkObject({\n    a: 1,\n    b: 2\n  })\n).to.deep.equal([\n  {\n    a: 1\n  },\n  {\n    b: 2\n  }\n])\n",
  "compactObject": "expect(\n  F.compactObject({\n    a: 1,\n    b: null,\n    c: false\n  })\n).to.deep.equal({\n  a: 1\n})\n",
  "isEmptyObject": "let expectEql = (obj, v) => expect(F.isEmptyObject(obj)).to.equal(v)\nexpectEql({ a: 1 }, false)\nexpectEql({}, true)\n",
  "isNotEmptyObject": "let expectEql = (obj, v) => expect(F.isNotEmptyObject(obj)).to.equal(v)\nexpectEql({ a: 1 }, true)\nexpectEql({}, false)\n",
  "stripEmptyObjects": "expect(\n  F.stripEmptyObjects({\n    a: 1,\n    b: {},\n    c: 2\n  })\n).to.deep.equal({\n  a: 1,\n  c: 2\n})\n",
  "pickInto": "expect(\n  F.pickInto(\n    {\n      a: ['a'],\n      b: ['b'],\n      c: ['c']\n    },\n    { a: 1, b: 2 }\n  )\n).to.deep.equal({\n  a: { a: 1 },\n  b: { b: 2 },\n  c: {}\n})\n",
  "unwind": "expect(F.unwind('x', { x: ['a', 'b'], y: 1 })).to.deep.equal([\n  { x: 'a', y: 1 },\n  { x: 'b', y: 1 }\n])\n// should unwind undefined values\nexpect(F.unwind('x', { x: ['a', undefined, 'b'], y: 1 })).to.deep.equal([\n  { x: 'a', y: 1 },\n  { x: undefined, y: 1 },\n  { x: 'b', y: 1 }\n])\n// should return an empty array for keys that are not present on the object\nexpect(F.unwind('z', { x: 'foo', y: 1 })).to.deep.equal([])\n// should also return an empty array for keys whose values can't be unwound\nexpect(F.unwind('y', { x: 'foo', y: 1 })).to.deep.equal([])\nexpect(F.unwind('y', { x: 'foo', y: undefined })).to.deep.equal([])\nexpect(F.unwind('y', { x: 'foo', y: [] })).to.deep.equal([])\n// should not unwind strings\nexpect(F.unwind('x', { x: 'foo', y: 1 })).to.deep.equal([])\n// duplicate objects are fine (we don't run _.uniq on the array to unwind)\nexpect(F.unwind('x', { x: [7, 7, 7], y: 1 })).to.deep.equal([\n  { x: 7, y: 1 },\n  { x: 7, y: 1 },\n  { x: 7, y: 1 }\n])\n",
  "unwindArray": "expect(\n  F.unwindArray('x', [\n    { x: ['a', 'b'], y: 1 },\n    { x: ['a', 'c'], y: 2 },\n    // since `unwind` returns an empty array for non-unwindable values,\n    // this should _not_ be present on the result of `unwindArray`\n    { x: 'd', y: 3 }\n  ])\n).to.deep.equal([\n  { x: 'a', y: 1 },\n  { x: 'b', y: 1 },\n  { x: 'a', y: 2 },\n  { x: 'c', y: 2 }\n  // { x: 'd', y: 3 },\n])\n// should not unwind strings\nexpect(\n  F.unwindArray('x', [\n    { x: 'foo', y: 1 },\n    { x: 'bar', y: 2 }\n  ])\n).to.deep.equal([])\nexpect(\n  F.unwindArray('x', [\n    { x: [7, 7, 7], y: 1 },\n    { x: [1, 1], y: 2 }\n  ])\n).to.deep.equal([\n  { x: 7, y: 1 },\n  { x: 7, y: 1 },\n  { x: 7, y: 1 },\n  { x: 1, y: 2 },\n  { x: 1, y: 2 }\n])\n",
  "flattenObject": "expect(\n  F.flattenObject({\n    a: {\n      b: {\n        c: 1\n      }\n    }\n  })\n).to.deep.equal({\n  'a.b.c': 1\n})\nexpect(\n  F.flattenObject([\n    {\n      a: {\n        b: [\n          {\n            c: 1\n          }\n        ]\n      }\n    }\n  ])\n).to.deep.equal({\n  '0.a.b.0.c': 1\n})\n",
  "unflattenObject": "expect(\n  F.unflattenObject({\n    'a.b.c': 1\n  })\n).to.deep.equal({\n  a: {\n    b: {\n      c: 1\n    }\n  }\n})\n",
  "renameProperty": "const o = { a: 1 }\nexpect(F.renameProperty('a', 'b', o)).not.to.deep.equal(o)\nexpect(F.renameProperty('a', 'b', o)).to.deep.equal({ b: 1 })\nexpect(F.renameProperty('c', 'b', o)).to.deep.equal({ a: 1 })\n",
  "matchesSignature": "expect(F.matchesSignature([], 0)).to.equal(false)\nexpect(F.matchesSignature([], '')).to.equal(false)\nexpect(F.matchesSignature([], x => x)).to.equal(true)\nexpect(F.matchesSignature([], [])).to.equal(true)\nexpect(F.matchesSignature([], { a: 1 })).to.equal(false)\nexpect(F.matchesSignature(['a'], { a: 1 })).to.equal(true)\nexpect(F.matchesSignature(['b'], { a: 1 })).to.equal(false)\nexpect(F.matchesSignature(['a'], { a: 1, b: 2 })).to.equal(false)\nexpect(F.matchesSignature(['a'], { a: undefined, b: undefined })).to.equal(\n  false\n)\nexpect(F.matchesSignature(['a', 'b'], { a: undefined })).to.equal(true)\n",
  "matchesSome": "expect(F.matchesSome({ a: 1, b: 2 })({ a: 1, b: 2, c: 3 })).to.deep.equal(true)\nexpect(F.matchesSome({ a: 1, b: 20 })({ a: 1, b: 2, c: 3 })).to.deep.equal(true)\nexpect(F.matchesSome({ a: 10, b: 2 })({ a: 1, b: 2, c: 3 })).to.deep.equal(true)\nexpect(F.matchesSome({ a: 10, b: 20 })({ a: 1, b: 2, c: 3 })).to.deep.equal(\n  false\n)\n",
  "compareDeep": "const o = { a: { b: { c: 1 } } }\nexpect(F.compareDeep('a.b.c', o, 1)).to.deep.equal(true)\nexpect(F.compareDeep('a.b.c', o, 2)).to.deep.equal(false)\nexpect(F.compareDeep('a.b.c')(o, '1')).to.deep.equal(false)\nexpect(F.compareDeep('a.b.c')(o)('1')).to.deep.equal(false)\n",
  "getOrReturn": "expect(F.getOrReturn('x', { a: 1 })).to.deep.equal({ a: 1 })\n",
  "alias": "expect(F.alias('x', { a: 1 })).to.deep.equal('x')\n",
  "aliasIn": "expect(F.aliasIn({ a: 1 }, 'x')).to.deep.equal('x')\n",
  "cascade": "expect(F.cascade(['x', 'y'], { a: 1, y: 2 })).to.deep.equal(2)\nexpect(F.cascade(['x', 'c'], { a: 1, y: 2 }, 2)).to.deep.equal(2)\nexpect(F.cascade(['x', x => x.y], { a: 1, y: 2 })).to.deep.equal(2)\nexpect(F.cascade(['x', 'y'], { a: 1, x: null, y: 2 })).to.deep.equal(2)\n",
  "cascadeIn": "expect(F.cascadeIn({ a: 1, y: 2 }, ['x', 'y'])).to.deep.equal(2)\n",
  "cascadeKey": "expect(F.cascadeKey(['x', 'y'], { a: 1, x: 2 })).to.deep.equal('x')\n",
  "cascadePropKey": "expect(F.cascadePropKey(['x', 'y'], { a: 1, x: null, y: 2 })).to.deep.equal('x')\n",
  "cascadeProp": "expect(F.cascadeProp(['x', 'y'], { a: 1, x: null, y: 2 })).to.deep.equal(null)\n",
  "unkeyBy": "expect(\n  F.unkeyBy('', {\n    a: {\n      x: 1\n    },\n    'd.e': {\n      x: 5\n    }\n  })\n).to.deep.equal([\n  {\n    x: 1,\n    a: 'a'\n  },\n  {\n    x: 5,\n    'd.e': 'd.e'\n  }\n])\n",
  "simpleDiff": "expect(\n  F.simpleDiff(\n    {\n      x: 1,\n      a: 3,\n      d: {\n        f: 6\n      },\n      price: 20,\n      notChanged: 45\n    },\n    {\n      x: 1,\n      a: 1,\n      b: 2,\n      c: 3,\n      d: {\n        e: 5\n      },\n      price: undefined,\n      amount: 20\n    }\n  )\n).to.deep.equal({\n  a: {\n    from: 3,\n    to: 1\n  },\n  b: {\n    from: undefined,\n    to: 2\n  },\n  c: {\n    from: undefined,\n    to: 3\n  },\n  'd.e': {\n    from: undefined,\n    to: 5\n  },\n  amount: {\n    from: undefined,\n    to: 20\n  },\n  price: {\n    from: 20,\n    to: undefined\n  }\n})\n",
  "simpleDiffArray": "expect(\n  F.simpleDiffArray(\n    {\n      x: 1,\n      a: 3,\n      d: {\n        f: 6\n      },\n      price: 20,\n      notChanged: 45\n    },\n    {\n      a: 1,\n      b: 2,\n      c: 3,\n      x: 1,\n      d: {\n        e: 5\n      },\n      price: undefined,\n      amount: 20\n    }\n  )\n).to.deep.equal([\n  {\n    field: 'a',\n    from: 3,\n    to: 1\n  },\n  {\n    field: 'b',\n    from: undefined,\n    to: 2\n  },\n  {\n    field: 'c',\n    from: undefined,\n    to: 3\n  },\n  {\n    field: 'd.e',\n    from: undefined,\n    to: 5\n  },\n  {\n    field: 'price',\n    from: 20,\n    to: undefined\n  },\n  {\n    field: 'amount',\n    from: undefined,\n    to: 20\n  }\n])\n",
  "diff": "expect(\n  F.diff(\n    {\n      x: 1,\n      a: 3,\n      d: {\n        f: 6\n      },\n      price: 20,\n      notChanged: 45\n    },\n    {\n      x: 1,\n      a: 1,\n      b: 2,\n      c: 3,\n      d: {\n        e: 5\n      },\n      price: undefined,\n      notChanged: 45,\n      amount: 20\n    }\n  )\n).to.deep.equal({\n  a: {\n    from: 3,\n    to: 1\n  },\n  b: {\n    from: undefined,\n    to: 2\n  },\n  c: {\n    from: undefined,\n    to: 3\n  },\n  'd.e': {\n    from: undefined,\n    to: 5\n  },\n  'd.f': {\n    from: 6,\n    to: undefined\n  },\n  amount: {\n    from: undefined,\n    to: 20\n  },\n  price: {\n    from: 20,\n    to: undefined\n  }\n})\n",
  "diffArray": "expect(\n  F.diffArray(\n    {\n      z: {},\n      x: 1,\n      a: 3,\n      d: {\n        f: 6\n      },\n      price: 20,\n      notChanged: 45,\n      collection1: [{ a: 1, b: 2 }],\n      collection2: [{ a: 1, b: 2 }]\n    },\n    {\n      z: { zz: 1 },\n      a: 1,\n      b: 2,\n      c: 3,\n      x: 1,\n      d: {\n        e: 5\n      },\n      price: undefined,\n      amount: 20,\n      notChanged: 45,\n      collection1: [{ a: 1 }],\n      collection2: []\n    }\n  )\n).to.deep.equal([\n  {\n    field: 'a',\n    from: 3,\n    to: 1\n  },\n  {\n    field: 'd.f',\n    from: 6,\n    to: undefined\n  },\n  {\n    field: 'price',\n    from: 20,\n    to: undefined\n  },\n  {\n    field: 'collection1.0.b',\n    from: 2,\n    to: undefined\n  },\n  {\n    field: 'collection2.0.a',\n    from: 1,\n    to: undefined\n  },\n  {\n    field: 'collection2.0.b',\n    from: 2,\n    to: undefined\n  },\n  {\n    field: 'z.zz',\n    from: undefined,\n    to: 1\n  },\n  {\n    field: 'b',\n    from: undefined,\n    to: 2\n  },\n  {\n    field: 'c',\n    from: undefined,\n    to: 3\n  },\n  {\n    field: 'd.e',\n    from: undefined,\n    to: 5\n  },\n  {\n    field: 'amount',\n    from: undefined,\n    to: 20\n  }\n])\n",
  "mergeAllArrays": "expect(\n  F.mergeAllArrays([\n    {\n      a: 1,\n      b: [2, 3]\n    },\n    {\n      a: 3,\n      b: [4]\n    }\n  ])\n).to.deep.equal({\n  a: 3,\n  b: [2, 3, 4]\n})\nexpect(F.mergeAllArrays([{ a: [1], b: 5 }, { a: [2] }])).to.deep.equal({\n  a: [1, 2],\n  b: 5\n})\n",
  "invertByArray": "expect(\n  F.invertByArray({\n    a: ['x', 'y', 'z'],\n    b: ['x']\n  })\n).to.deep.equal({\n  x: ['a', 'b'],\n  y: ['a'],\n  z: ['a']\n})\n",
  "stampKey": "expect(\n  F.stampKey('type', {\n    foo: {\n      a: 1,\n      b: 2\n    },\n    bar: {}\n  })\n).to.deep.equal({\n  foo: {\n    a: 1,\n    b: 2,\n    type: 'foo'\n  },\n  bar: {\n    type: 'bar'\n  }\n})\n",
  "omitNil": "expect(F.omitNil({ a: 1, b: 'c', d: null, e: undefined })).to.deep.equal({\n  a: 1,\n  b: 'c'\n})\n",
  "omitNull": "expect(F.omitNull({ a: 1, b: 'c', d: null, e: undefined })).to.deep.equal({\n  a: 1,\n  b: 'c',\n  e: undefined\n})\n",
  "omitBlank": "expect(\n  F.omitBlank({ a: 1, b: 'c', d: null, e: undefined, f: [], g: {}, h: '' })\n).to.deep.equal({\n  a: 1,\n  b: 'c'\n})\n",
  "omitEmpty": "expect(\n  F.omitEmpty({ a: 1, b: 'c', d: null, e: undefined, f: [], g: {}, h: '' })\n).to.deep.equal({\n  b: 'c'\n})\n",
  "mergeOverAll": "let foo = x => ({ [x]: 'foo' })\nlet bar = x => ({ bar: x, [x]: 'bar' })\nexpect(F.mergeOverAll([foo, bar])('a')).to.deep.equal({\n  a: 'bar',\n  bar: 'a'\n})\nexpect(F.mergeOverAll([bar, foo])('a')).to.deep.equal({\n  a: 'foo',\n  bar: 'a'\n})\n// should NOT merge arrays\nlet qux = a => ({ x: a.map(x => x + 3) })\nexpect(F.mergeOverAll([x => ({ x }), qux])([1, 2, 3])).to.deep.equal({\n  x: [4, 5, 6]\n})\n// documenting edge case behavior\nexpect(F.mergeOverAll(undefined, undefined)).to.deep.equal({})\nexpect(F.mergeOverAll(undefined)(undefined)).to.deep.equal({})\nexpect(F.mergeOverAll([])(undefined)).to.deep.equal(undefined)\nexpect(F.mergeOverAll([x => x, (x, y) => y])('abc', 'de')).to.deep.equal({\n  0: 'd',\n  1: 'e',\n  2: 'c'\n})\n",
  "mergeOverAllWith": "let reverseArrayCustomizer = (objValue, srcValue) =>\n  srcValue.length ? srcValue.reverse() : srcValue\nlet qux = a => ({ x: a.map(x => x + 3) })\nexpect(\n  F.mergeOverAllWith(reverseArrayCustomizer, [() => ({}), qux])([1, 2, 3])\n).to.deep.equal({ x: [6, 5, 4] })\n",
  "mergeOverAllArrays": "// should merge arrays\nlet qux = a => ({ x: a.map(x => x + 3) })\nexpect(F.mergeOverAllArrays([x => ({ x }), qux])([1, 2, 3])).to.deep.equal({\n  x: [1, 2, 3, 4, 5, 6]\n})\n",
  "getWith": "let square = x => x * x\nlet getWithSquare = F.getWith(square)\nlet foo = { a: 1, b: 3, c: 5 }\nexpect(getWithSquare('c', foo)).to.equal(25)\nexpect(F.getWith(x => x + 1, 'b', foo)).to.equal(4)\n// edge case: throws when customizer is not a function\nexpect(() => F.getWith(undefined, 'b', foo)).to.throw(TypeError)\n",
  "expandObject": "let foo = { a: 1, b: 2, c: 'a' }\n// should expand object\nlet toOptions = F.mapIndexed((v, k) => ({ label: k, value: v }))\nexpect(F.expandObject(obj => ({ options: toOptions(obj) }), foo)).to.deep.equal(\n  {\n    a: 1,\n    b: 2,\n    c: 'a',\n    options: [\n      { label: 'a', value: 1 },\n      { label: 'b', value: 2 },\n      { label: 'c', value: 'a' }\n    ]\n  }\n)\n// should override keys\nexpect(F.expandObject(_.invert, foo)).to.deep.equal({\n  '1': 'a',\n  '2': 'b',\n  a: 'c',\n  b: 2,\n  c: 'a'\n})\n",
  "expandObjectBy": "let primeFactorization = x => (x === 42 ? { '2': 1, '3': 1, '7': 1 } : 'dunno')\nlet foo = { a: 1, b: 42 }\nexpect(F.expandObjectBy('b', primeFactorization, foo)).to.deep.equal({\n  a: 1,\n  b: 42,\n  '2': 1,\n  '3': 1,\n  '7': 1\n})\nexpect(F.expandObjectBy('a', primeFactorization, foo)).to.deep.equal({\n  '0': 'd',\n  '1': 'u',\n  '2': 'n',\n  '3': 'n',\n  '4': 'o',\n  a: 1,\n  b: 42\n})\n",
  "commonKeys": "let providers = {\n  mongo: {},\n  elasticsearch: {}\n}\nlet schema = {\n  fields: {},\n  elasticsearch: {},\n  mongo: {}\n}\n\nexpect(F.commonKeys(providers, schema)).to.deep.equal([\n  'elasticsearch',\n  'mongo'\n])\nexpect(F.commonKeys(providers)(schema)).to.deep.equal([\n  'elasticsearch',\n  'mongo'\n])\n",
  "firstCommonKey": "let providers = {\n  mongo: {},\n  elasticsearch: {}\n}\nlet schema = {\n  fields: {},\n  elasticsearch: {},\n  mongo: {}\n}\n\nexpect(F.firstCommonKey(providers, schema)).to.equal('elasticsearch')\n",
  "testRegex": "expect(f.testRegex(/smart/i)('SmartProcure')).to.equal(true)\nexpect(f.testRegex(/smart/)('SmartProcure')).to.equal(false)\n",
  "makeRegExp": "const reText = 'Some text'\nconst options = 'gi'\nconst regExp = RegExp(reText, options)\n\nexpect(f.makeRegex(options)(reText)).to.deep.equal(regExp)\n",
  "makeAndTest": "const reText = 'Some text'\nconst options = 'gi'\nconst text = 'Here is some text to test'\nconst regex = RegExp(reText, options)\nconst result = regex.test(text)\n\nexpect(f.makeAndTest(options)(reText)(text)).to.deep.equal(result)\n",
  "matchAnyWord": "const reText = 'Some text'\nconst text = 'Here is some text to test'\nconst match = f.matchAnyWord(reText)\n\nexpect(match(text)).to.equal(true)\n",
  "matchAllWords": "const reText = 'Some text'\nconst text = 'Here is some to test'\nconst match = f.matchAllWords(reText)\n\nexpect(match(text)).to.equal(false)\n",
  "return all matched results": "const re = '(\\\\d+)'\nconst text = `1 22 333 a bb ccc 4444`\nconst matches = f.allMatches(re, text)\nexpect(matches).to.deep.equal([\n  { text: '1', start: 0, end: 1 },\n  { text: '22', start: 2, end: 4 },\n  { text: '333', start: 5, end: 8 },\n  { text: '4444', start: 18, end: 22 }\n])\n",
  "get postings": "var result = f.postings(RegExp('p', 'gi'), 'pretty please')\nexpect(result).to.deep.equal([\n  [0, 1],\n  [7, 8]\n])\n",
  "get postings by word": "var result = f.postingsForWords('pret pr t ', 'pretty prease')\nexpect(result).to.deep.equal([\n  [[0, 4]],\n  [\n    [0, 2],\n    [7, 9]\n  ],\n  [\n    [3, 4],\n    [4, 5]\n  ]\n])\n",
  "highlight": "let input = 'pretty please'\nlet postings = f.postings(RegExp('p', 'gi'), input)\nlet expected =\n  '<span class=\"highlight\">p</span>retty <span class=\"highlight\">p</span>lease'\nexpect(f.highlightFromPostings(start, end, postings, input)).to.equal(expected)\n",
  "highlight backwards postings": "let input = 'pretty please'\nlet expected =\n  '<span class=\"highlight\">p</span>retty <span class=\"highlight\">p</span>lease'\nexpect(\n  f.highlightFromPostings(\n    start,\n    end,\n    [\n      [7, 8],\n      [0, 1]\n    ],\n    input\n  )\n).to.equal(expected)\n",
  "high level highlight": "let input = 'pretty please'\nlet pattern = 'pr pl'\nlet expected =\n  '<span class=\"highlight\">pr</span>etty <span class=\"highlight\">pl</span>ease'\nexpect(f.highlight(start, end, pattern, input)).to.deep.equal(expected)\n",
  "highlight from regexp": "let input = 'pretty please nope'\nlet pattern = /\\bp\\w/g\nlet expected =\n  '<span class=\"highlight\">pr</span>etty <span class=\"highlight\">pl</span>ease nope'\nexpect(f.highlight(start, end, pattern, input)).to.deep.equal(expected)\n",
  "wrap": "let wrapped = '(asdf)'\nexpect(F.wrap('(', ')', 'asdf')).to.equal(wrapped)\nexpect(F.wrap(null, null, 'asdf')).to.equal('asdf')\n",
  "quote": "expect(F.quote('asdf')).to.equal('\"asdf\"')\n",
  "parens": "let wrapped = '(asdf)'\nexpect(F.parens('asdf')).to.equal(wrapped)\n",
  "concatStrings": "expect(F.concatStrings(['This ', '  is a  ', null, '', 'sentence!'])).to.equal(\n  'This is a sentence!'\n)\n",
  "trimStrings": "expect(\n  F.trimStrings(['This ', '  is a  ', null, '', 'sentence!'])\n).to.deep.equal(['This', 'is a', null, '', 'sentence!'])\nexpect(\n  F.trimStrings({ a: 'a', b: ' b ', c: 'c ', d: ' d', e: 5 })\n).to.deep.equal({ a: 'a', b: 'b', c: 'c', d: 'd', e: 5 })\n",
  "autoLabel": "expect(\n  F.autoLabel('whatDoYouThinkOfThisHTML5Stuff? IThinkItIsREALLYCool')\n).to.equal('What Do You Think Of This HTML 5 Stuff I Think It Is REALLY Cool')\nexpect(F.autoLabel('thisIsAVariable')).to.equal('This Is A Variable')\nexpect(\n  F.autoLabel('thisIs_startCaseWithACRONYMSAndNumbersLike123and4')\n).to.equal('This Is Start Case With ACRONYMS And Numbers Like 123 And 4')\n// Passive aggressive example of how to better auto generate PR titles from branch names...\nexpect(F.autoLabel('Feature/AutoLabel#126')).to.equal('Feature Auto Label 126')\n",
  "autoLabelOption": "expect(F.autoLabelOption('someValue')).to.deep.equal({\n  value: 'someValue',\n  label: 'Some Value'\n})\n",
  "autoLabelOptions": "expect(\n  F.autoLabelOptions([\n    { value: '', label: 'Empty String Value' },\n    'someValue',\n    { value: 'justAValue' },\n    { value: 'bothValueAndLabel', label: 'Custom Label' }\n  ])\n).to.deep.equal([\n  { value: '', label: 'Empty String Value' },\n  { value: 'someValue', label: 'Some Value' },\n  { value: 'justAValue', label: 'Just A Value' },\n  { value: 'bothValueAndLabel', label: 'Custom Label' }\n])\n",
  "toSentenceWith": "expect(F.toSentenceWith(' - ', ' or ', ['first', 'second', 'third'])).to.equal(\n  'first - second or third'\n)\n",
  "toSentence": "expect(F.toSentence(['first', 'second', 'third'])).to.equal(\n  'first, second and third'\n)\n",
  "uniqueString": "let dedupe = F.uniqueString([])\nexpect(dedupe.cache).to.deep.equal({})\nexpect(\n  _.map(\n    dedupe,\n    _.times(() => 'foo', 5)\n  )\n).to.deep.equal(['foo', 'foo1', 'foo2', 'foo3', 'foo4'])\nexpect(dedupe.cache).to.deep.equal({\n  foo: 5,\n  foo1: 1,\n  foo2: 1,\n  foo3: 1,\n  foo4: 1\n})\nexpect(F.uniqueString(_.keys(dedupe.cache))('foo')).to.equal('foo5')\n// should cache result strings to avoid conflicts with user-specified strings that\n// would have matched a uniqueString result\nlet badFoos = ['foo', 'foo1', 'foo', 'foo2', 'foo', 'foo3', 'foo']\nexpect(_.map(F.uniqueString([]), badFoos)).to.deep.equal([\n  'foo',\n  'foo1',\n  'foo2',\n  'foo21',\n  'foo3',\n  'foo31',\n  'foo4'\n])\nlet text = _.words(`\n      Creates a function that invokes func with the arguments of the created function. If\n      func is a property name, the created function returns the property value for a given\n      element. If func is an array or object, the created function returns true for elements\n      that contain the equivalent source properties, otherwise it returns false.\n    `)\nexpect(_.size(_.uniq(text))).not.to.equal(text.length)\nlet uniqueText = _.map(F.uniqueString(), text)\nexpect(_.size(_.uniq(uniqueText))).to.equal(uniqueText.length)\n// clearing should work\ndedupe.clear()\nexpect(dedupe.cache).to.deep.equal({})\n// should handle calling with no arguments\nexpect(F.uniqueString(null)('test')).to.be.a('string')\nexpect(F.uniqueString(undefined)('test')).to.be.a('string')\nexpect(F.uniqueString()('test')).to.be.a('string')\n",
  "uniqueStringWith": "let a = ['foo20', 'foo21', 'foo23', 'foo24', 'foo25']\nlet stripDigits = F.arrayToObject(_.replace(/(\\d+)$/, ''), () => 1)\nlet uniqueStringStripDigits = F.uniqueStringWith(stripDigits, a)\nexpect(uniqueStringStripDigits.cache).to.deep.equal({ foo: 1 })\nexpect(uniqueStringStripDigits('foo')).to.equal('foo1')\n// Should work with appending other stuff if you really want to\nlet appendHiForSomeReason = F.arrayToObject(_.identity, () => 'hi')\nexpect(\n  _.map(F.uniqueStringWith(appendHiForSomeReason, ['foo']), [\n    'foo',\n    'foo',\n    'bar'\n  ])\n).to.deep.equal(['foohi', 'foohi1', 'bar'])\n",
  "isTraversable": "expect(F.isTraversable([])).to.equal(true)\nexpect(F.isTraversable({})).to.equal(true)\nexpect(F.isTraversable('')).to.equal(false)\nexpect(F.isTraversable(5)).to.equal(false)\n",
  "traverse": "let x = {\n  a: 1,\n  b: {\n    c: 2\n  }\n}\nexpect(F.traverse(x)).to.deep.equal(x)\n",
  "pre-order traversal": "F.walk()(tree => {\n  values.push(tree)\n})(x)\nexpect(values).to.deep.equal([x, x.a, x.b, x.b.c])\n",
  "post-order traversal": "let values = []\nF.walk()(\n  () => {},\n  tree => {\n    values.push(tree)\n  }\n)(x)\nexpect(values).to.deep.equal([x.a, x.b.c, x.b, x])\n",
  "halting": "let values = []\nlet r = F.walk()(tree => {\n  values.push(tree)\n  return _.isNumber(tree)\n})(x)\nexpect(values).to.deep.equal([x, x.a])\nexpect(r).to.equal(x.a)\n",
  "halting with tree return": "let values = []\nlet r = F.walk()(\n  () => {},\n  (tree, i, [parent]) => {\n    values.push(tree)\n    if (!parent) return tree\n  }\n)(x)\nexpect(values).to.deep.equal([x.a, x.b.c, x.b, x])\nexpect(r).to.equal(x)\n",
  "retain parent stack and indices": "let values = []\nF.walk()((x, i, parents) => {\n  values.push([x, parents, i])\n})(x)\nexpect(values).to.deep.equal([\n  [x, [], undefined],\n  [x.a, [x], 'a'],\n  [x.b, [x], 'b'],\n  [x.b.c, [x.b, x], 'c']\n])\n",
  "reduceTree": "let x = {\n  a: 1,\n  b: {\n    c: 2\n  }\n}\nexpect(F.reduceTree()((r, i) => F.push(i, r), [], x)).to.deep.equal([\n  x,\n  x.a,\n  x.b,\n  x.b.c\n])\n",
  "treeToArray": "let x = {\n  a: 1,\n  b: {\n    c: 2\n  }\n}\nexpect(F.treeToArray()(x)).to.deep.equal([x, x.a, x.b, x.b.c])\n",
  "treeToArrayBy": "let x = {\n  a: 1,\n  b: {\n    c: 2\n  }\n}\nexpect(F.treeToArrayBy()(i => (_.isNumber(i) ? i * 2 : i), x)).to.deep.equal([\n  x,\n  x.a * 2,\n  x.b,\n  x.b.c * 2\n])\n",
  "leaves": "let x = {\n  a: 1,\n  b: {\n    c: 2\n  }\n}\nexpect(F.leaves()(x)).to.deep.equal([1, 2])\n",
  "tree": "let x = {\n  a: 1,\n  b: {\n    c: 2\n  }\n}\nlet tree = F.tree()\nexpect(tree.toArray(x)).to.deep.equal([x, x.a, x.b, x.b.c])\n",
  "lookup": "let x = {\n  a: 1,\n  items: [\n    {\n      a: 2,\n      items: [\n        {\n          a: 3\n        },\n        {\n          a: 4,\n          b: 4\n        }\n      ]\n    },\n    {\n      a: 5\n    }\n  ]\n}\nlet tree = F.tree(x => x.items)\n\nexpect(tree.lookup([{ a: 2 }, { a: 4 }], x)).to.deep.equal(x.items[0].items[1])\n",
  "lookup with path": "let x = {\n  a: '1',\n  items: [\n    {\n      a: '2',\n      items: [\n        {\n          a: '3'\n        },\n        {\n          a: '4',\n          b: 4\n        }\n      ]\n    },\n    {\n      a: '5'\n    }\n  ]\n}\nlet tree = F.tree(\n  x => x.items,\n  a => ({ a })\n)\nexpect(tree.lookup(['2', '4'], x)).to.deep.equal(x.items[0].items[1])\n",
  "transform": "let x = {\n  a: '1',\n  items: [\n    {\n      a: '2',\n      items: [\n        {\n          a: '3'\n        },\n        {\n          a: '4',\n          b: 4\n        }\n      ]\n    },\n    {\n      a: '5'\n    }\n  ]\n}\nexpect(\n  F.transformTree(x => x.items)(x => {\n    x.b = 'transformed'\n  }, x)\n).to.deep.equal({\n  a: '1',\n  b: 'transformed',\n  items: [\n    {\n      a: '2',\n      b: 'transformed',\n      items: [\n        {\n          a: '3',\n          b: 'transformed'\n        },\n        {\n          a: '4',\n          b: 'transformed'\n        }\n      ]\n    },\n    {\n      a: '5',\n      b: 'transformed'\n    }\n  ]\n})\nexpect(x).to.deep.equal({\n  a: '1',\n  items: [\n    {\n      a: '2',\n      items: [\n        {\n          a: '3'\n        },\n        {\n          a: '4',\n          b: 4\n        }\n      ]\n    },\n    {\n      a: '5'\n    }\n  ]\n})\n",
  "keyByWith": "let x = {\n  a: 'first',\n  items: [\n    {\n      a: 'second',\n      items: [\n        {\n          a: 'first'\n        },\n        {\n          a: 'second',\n          b: 4\n        },\n        {\n          a: 'second',\n          b: 6\n        }\n      ]\n    },\n    {\n      a: 'second'\n    }\n  ]\n}\nlet tree = F.tree(x => x.items)\n\nexpect(\n  tree.keyByWith(\n    (x, matches, group) => {\n      if (matches) x.type = `${group} type`\n    },\n    'a',\n    x\n  )\n).to.deep.equal({\n  first: {\n    a: 'first',\n    type: 'first type',\n    items: [\n      {\n        a: 'second',\n        items: [\n          {\n            a: 'first',\n            type: 'first type'\n          },\n          {\n            a: 'second',\n            b: 4\n          },\n          {\n            a: 'second',\n            b: 6\n          }\n        ]\n      },\n      {\n        a: 'second'\n      }\n    ]\n  },\n  second: {\n    a: 'first',\n    items: [\n      {\n        a: 'second',\n        type: 'second type',\n        items: [\n          {\n            a: 'first'\n          },\n          {\n            a: 'second',\n            type: 'second type',\n            b: 4\n          },\n          {\n            a: 'second',\n            type: 'second type',\n            b: 6\n          }\n        ]\n      },\n      {\n        a: 'second',\n        type: 'second type'\n      }\n    ]\n  }\n})\n",
  "flattenTree": "let properties = {\n  Field1: {\n    type: 'text'\n  },\n  Field2: {\n    properties: {\n      Field2A: {\n        properties: {\n          Field2A1: {\n            type: 'text'\n          },\n          Field2A2: {\n            type: 'text'\n          },\n          Field2A3: {\n            properties: {\n              Field2A3a: {\n                type: 'text'\n              }\n            }\n          }\n        }\n      },\n      Field2B: {\n        type: 'text'\n      },\n      Field2C: {\n        type: 'text'\n      }\n    }\n  }\n}\nlet Tree = F.tree(x => x.properties)\nlet result = _.flow(Tree.flatten(), _.omitBy(Tree.traverse))({ properties })\nexpect(result).to.deep.equal({\n  Field1: {\n    type: 'text'\n  },\n  'Field2.Field2A.Field2A1': {\n    type: 'text'\n  },\n  'Field2.Field2A.Field2A2': {\n    type: 'text'\n  },\n  'Field2.Field2A.Field2A3.Field2A3a': {\n    type: 'text'\n  },\n  'Field2.Field2B': {\n    type: 'text'\n  },\n  'Field2.Field2C': {\n    type: 'text'\n  }\n})\n",
  "flattenTree with propTreePath": "let Tree = F.tree(x => x.children)\nlet result = Tree.flatten(F.propTreePath('key'))({\n  key: 'root',\n  children: [\n    {\n      key: 'criteria',\n      children: [\n        {\n          key: 'filter'\n        }\n      ]\n    },\n    {\n      key: 'analysis',\n      children: [\n        {\n          key: 'results'\n        }\n      ]\n    }\n  ]\n})\nexpect(result).to.deep.equal({\n  root: {\n    key: 'root',\n    children: [\n      {\n        key: 'criteria',\n        children: [\n          {\n            key: 'filter'\n          }\n        ]\n      },\n      {\n        key: 'analysis',\n        children: [\n          {\n            key: 'results'\n          }\n        ]\n      }\n    ]\n  },\n  'root/analysis': {\n    key: 'analysis',\n    children: [\n      {\n        key: 'results'\n      }\n    ]\n  },\n  'root/analysis/results': {\n    key: 'results'\n  },\n  'root/criteria': {\n    key: 'criteria',\n    children: [\n      {\n        key: 'filter'\n      }\n    ]\n  },\n  'root/criteria/filter': {\n    key: 'filter'\n  }\n})\nexpect(Tree.flatLeaves(result)).to.deep.equal([\n  {\n    key: 'filter'\n  },\n  {\n    key: 'results'\n  }\n])\n",
  "findIndexedAsync": "let findIndexedAsyncTest = await F.findIndexedAsync(\n  async x => {\n    await Promise.delay(10)\n    return x % 2 === 0\n  },\n  [1, 2, 3]\n)\nexpect(findIndexedAsyncTest).to.equal(2)\n",
  "walkAsync": "let tree = {\n  a: {\n    b: {\n      c: [1, 2, 3]\n    }\n  }\n}\nlet walkAsyncTest = F.walkAsync()(async node => {\n  await Promise.delay(10)\n  if (_.isArray(node)) node.push(4)\n})(tree)\nexpect(tree.a.b.c.length).to.equal(3)\nawait walkAsyncTest\nexpect(tree.a.b.c.length).to.equal(4)\n",
  "walkAsync with sync": "let tree = {\n  a: {\n    b: {\n      c: [1, 2, 3]\n    }\n  }\n}\nlet walkAsyncTest = F.walkAsync()(node => {\n  if (_.isArray(node)) node.push(4)\n})(tree)\nexpect(tree.a.b.c.length).to.equal(3)\nawait walkAsyncTest\nexpect(tree.a.b.c.length).to.equal(4)\n"
}